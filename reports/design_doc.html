<section>
<style>
.note {
     color: #3bb655;
 }
.todo {
     color: #fc2828;
 }
</style>
<dl>
    <dt><h2 id="header-design">Design Document</h2></dt>
    <dd>

        <!--  Start Introduction  -->
        <dl>
            <dt><h3>Introduction</h3></dt>
            <dd>
                We are tasked with creating a compiler for a subset of the C programming language. With this challenge includes figuring out how to implement the three fundamental parts of any compiler: Frontend, Optimization, and the Backend. Our goal with this project is not only to design and implement an optimizing compiler, but to strengthen our ability to design and create software that achieves its purpose and provides adequate documentation to explain how it operates.
            </dd>
            <dt><h3>Language / Libraries / References</h3></dt>
            <dd>
                <ul>
                    <li>Python 3.7+</li>
                    <li> <a href="https://github.com/alex/rply">Rply</a>, Python's re-implimentation of Lex-and-Yacc</li>
                    <li> <a href="https://github.com/pdoc3/pdoc">Pdoc3</a>, used for documentation</li>
                    <li> <a href="https://vallentin.dev/2016/11/29/pretty-print-tree">Pretty printing the tree</a> </li>
                </ul>
            </dd>
        </dl>
        <!--  End Introduction  -->




        <!--  Start Architecture  -->
        <dl>
            <dt><h3>Architecture</h3></dt>
            <dd>
                Our compiler can be split into three major stages that takes 
                in a C program and converts this "High-Level" language into 
                many different forms of Intermediate Representations (IR's) 
                until it reaches the point of assembly code.
            </dd>
            <img id="architecture_img" src="./architecture.png" />
        </dl>
        <!--  End Architecture Section  -->





        <!--  Start Frontend  -->
        <dl>
            <dt><h3>Frontend</h3></dt>
            <dd>
                <dl>
                    <dt><h4>Lexer</h4></dt>
                    <dd>
                        Responsible for scanning and assigning tokens to 
                        different elements of our C program, this module was 
                        designed using RPLY's lexer class. By simply adding in 
                        tokens to our lexer we are able to give it a string version 
                        of our C program and get a list of all valid tokens.
                        <dl>
                            <dt><h5>Token Format / Examples</h5></dt>
                            <dd>
                                <pre>Token("TOKEN_NAME", "ELEMENT")
                                
Token("INTEGER", "1")
Token("COMPARISON", ">")
Token("SELF_DEFINED", "some-variable-name")
Token("LOGICAL", "&&")
Token("ACCESS", "->")</pre>
                            </dd>
                            <dt><h5>Error Handling</h5></dt>
                            <dd>
                                Currently the only known errors we can experience 
                                while using RPLY's lexer library is when we encounter 
                                an element that isn't recognized. By adding an <code>INVALID</code> 
                                token type, and having it match to any string combination, 
                                we eliminate the possibility of the imported lexer code to 
                                fail, and are able to report any invalid tokens to the user.
                            </dd>
                        </dl>
                    </dd>
                    <dt><h4>Parser</h4></dt>
                    <dl>
                        <dd>
                            This sub-module relies on RPLY's parser generator but still 
                            requires a grammar. After defining a grammar in a separate 
                            file we can construct a parser using RPLY syntax that will 
                            take in the grammar and build our Parse Tree. Currently RPLY 
                            has allowed us to impliment a "Bottom-up left-to-right" parser.
                        <dl><dt><h5>Example of BNF grammar</h5><dd>
                            <pre>
program : definitionList #program

definitionList : functionDefinition definitionList #definitionList
definitionList : functionDeclaration definitionList #definitionList
definitionList : initialization SEMICOLON definitionList #definitionList
definitionList : #definitionList

functionDefinition : TYPE SELF_DEFINED OPEN_PAREN args CLOSE_PAREN block #function definition
functionDefinition : TYPE SELF_DEFINED OPEN_PAREN CLOSE_PAREN block #function definition

functionDeclaration : TYPE SELF_DEFINED OPEN_PAREN args CLOSE_PAREN SEMICOLON #functionDeclaration
functionDeclaration : TYPE SELF_DEFINED OPEN_PAREN CLOSE_PAREN SEMICOLON #functionDeclaration

args : TYPE SELF_DEFINED COMMA args #args
args : TYPE SELF_DEFINED #args
args : TYPE #args
args : TYPE COMMA args #args

block : OPEN_BRACE block content CLOSE_BRACE #block
block : OPEN_BRACE content block CLOSE_BRACE #block
...</pre>
                            <a target="_blank" href="https://github.com/bensonalec/CSE423_Compilers/blob/master/src/frontend/BNF_definition">Our Full BNF</a>
                            <p class="todo">
                                TODO: 
                                <ul class="todo">
                                    <li>We are only reporting the last successful token parsed 
                                        but not giving a detailed and more "useful" message. 
                                        We should work on this.</li>
                                </ul>
                            </p>
                        </dd></dd></dl>

                        <dt><h4>Abstract Syntax Tree Builder</h4></dt><dl>

                        <dd>
                            Using the initial Parse Tree, we are able to shorten it down and "abstract" it to have
                            a more understandable and syntax-free way to represent a C program. We currently have a single 
                            function, <code>buildAST(parseTreeHead)</code>, that constructs a series of <code>ASTNode</code> objects
                            with references to each other. Represented in the correct way, this creates a "Tree" data type.

                            <dl>
                                <dt><h5>Representing a Program</h5></dt>
                                    <dd>
                                        Every AST produced by our compiler will start with <code>program</code> denoting the root 
                                        of the C program. Following this root, there could be a series of function prototypes, <code>decl</code>, 
                                        and function declarations, <code>func</code>. Whether it be a prototype or declaration there will always be 3 
                                        branches that describe the Type, Function-Name, and Function-Parameters. In the case of a declaration, an extra node marked <code>body</code> 
                                        will link to the actual body of the function. Other keywords such as <code>var</code> (variables), <code>call</code> (function calls), and 
                                        arithmetic operations (+, -, *, /, etc.) exist in the produced AST if such content exists in the original C program.
                                    </dd>
                            
                                    <dd>
                                        Example AST representations can be found under: <a href="#section_10">Examples of C Programs and their Intermediate Representations</a>.
                                    </dd>
                            </dl>

                        </dd>
                        </dl>

                        <dt><h4>Semantic Analysis</h4></dt><dl>

                        <dd>
                            Our semantic analysis include checks for Undeclared functions/variables, 
                            type mismatch (for the possibility of types other than Int), 
                            correct number/types of function parameters.

                            <p class="note">
                                NOTE: There is a possibility of more stages of semantic analysis being implimented 
                                in the future, but it would be a supplemental feature for this project.
                            </p>
                            
                            <dl>
                                <dt><h5>Symbol Table</h5></dt>
                                    <dd>
                                        By constructing a symbol table using our AST, it becomes a lot easier to perform analysis on the C program.
                                        This table contains properties such as:
                                        <ul>
                                            <li>Name</li>
                                            <li>Entry type ie. function, variable, label, etc.</li>
                                            <li>Type ie. int, double, float, etc.</li>
                                            <li>Scope</li>
                                            <li>References in the program</li>
                                            <li>Modifiers (if any)</li>
                                        </ul>
                                        Along with all the "Known" symbols we also store the "Unknown" symbols which would cause warnings to be
                                        shown to the user.
                                    </dd>
                                    <dd>
                                        Example symbol tables can be found under: <a href="#section_10">Examples of C Programs and their Intermediate Representations</a>.
                                    </dd>
                            </dl>

                        </dd>
                        </dl>

                        <!-- <dt><h4>TITLE</h4></dt><dl>

                        <dd>
                            DESCRIPTION
                            
                            <dl>
                                <dt><h5>SUB-TITLE</h5></dt>
                                    <dd>
                                        BODY
                                    </dd>
                            
                                <dt><h5>SUB-TITLE</h5></dt>
                                    <dd>
                                        BODY
                                    </dd>
                            </dl>

                        </dd> 
                        </dl> -->

                    </dl>
                </dd>
                </dl>
                <!--  End Frontend  -->




                <!--  Start Optimization  -->

                <dl>
                    <dt><h3>Optimization</h3></dt>
                        <dd>
                        <dl>

                            <dt><h4>Intermediate Representations</h4></dt><dl>

                            <dd>
                                The basis of our optimization compenent of the compiler is converting one IR to another 
                                throughout the process of optimizing. The last IR is then used to construct the assembly code in the Backend.
                                There are a few options that we need to consider with constructing the intermediate representations: Is it being built 
                                from scratch, is it being imported, and how many optimizations are needed.
                                
                                <dl>
                                    <dt><h5>Building an IR (from AST)</h5></dt>
                                        <dd>
                                            We construct an IR by grouping together IR instructions into IR Objects. 
                                            These IR Objects can be either <code>IRLine's</code> or <code>IRNode's</code>. <code>IRLine's</code> contain smaller <code>IRNode's</code> such as assignments, arithmetic, goto jumps etc. 
                                            Of course not all IR instructions need to be broken down into smaller <code>IRNodes</code> so they are stored as the IR objects themselves. 
                                            These are defined and split up as such:
                                            <ul>
                                                <li>IRJump -- IR node for a jump label.</li>
                                                <li>IRGoTo -- IR node for a goto label.</li>
                                                <li>IRIf -- IR node for an if statement.</li>
                                                <li>IRArth -- IR node for an arithmetic/assignment operation.</li>
                                                <li>IRFunction -- IR node for a function call assignment.</li>
                                                <li>etc...</li>
                                            </ul>
                                            The design decision to have different IR instructions as their individual data type (that inherit from same parent class), 
                                            was to have a way of storing these instructions not as a String yet still having a way to be converted to a String for visual representation. Each IR node has its own
                                            string representation (As close to <strong>Gimple</strong> as we could achieve). This also allows us to optimize different elements of 
                                            the IR according to the type of instruction.
                                            <dd>
                                            All said and done, when an IR is constructed, we are left with a list of IR objects either representing single IR instructions (IRNode's) or multiple IR instructions (IRLine's). 
                                            </dd>
                                        </dd>
                                
                                    <!-- <dt><h5>Importing an IR</h5></dt>
                                        <dd>
                                            BODY
                                        </dd>

                                    <dt><h5>Optimizing an IR</h5></dt>
                                        <dd>
                                            BODY
                                        </dd> -->
                                </dl>

                            </dd> 

                        </dl>
                        </dd>
                </dl>

                <!--  End Optimization  -->
            </dd>
        </dl>
    </dd>
</dl>
</section>
