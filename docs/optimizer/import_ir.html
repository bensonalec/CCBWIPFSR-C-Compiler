<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.optimizer.import_ir API documentation</title>
<meta name="description" content="This module handles ir input from a file" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.optimizer.import_ir</code></h1>
</header>
<section id="section-intro">
<p>This module handles ir input from a file</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module handles ir input from a file
&#34;&#34;&#34;
from rply import LexerGenerator
from rply.errors import LexingError
from copy import deepcopy
import re
import os
from inspect import getsourcefile
from importlib.machinery import SourceFileLoader

irl = SourceFileLoader(&#34;IRLine&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/IRLine.py&#34;).load_module()

class import_ir():
    def __init__(self, filename):
        &#34;&#34;&#34;
        This function initializes the object that imports the IR, it takes in the filename of the file being imported.

        Args:
            filename: The filename of the IR

        &#34;&#34;&#34;
        self.IR = []
        with open(filename,&#34;r&#34;) as fd:
            self.data = fd.read()
            self.tokens = None

    def tokenize(self):
        &#34;&#34;&#34;
        This will tokenize the IR that has been read in.

        &#34;&#34;&#34;

        text_input = self.data.strip()
        lexer = IR_Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        self.tokens = tokens

    def parse(self):
        &#34;&#34;&#34;
        This function parses the IR after it has been tokenized, and returns the list of lines in the IR as IRNodes

        Returns:
            A list of the IRNodes that make up this IR file
        &#34;&#34;&#34;

        pg = Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(self.tokens)

        head = pg.getTree()
        # here, sort the list of IRNodes that have been generated by the parser,
        # since the bottom up nature of the parse means it will parse function_definitions after lines
        finalLs = []
        tempLs = []
        for i in pg.ls:
            if(isinstance(i,irl.IRFunctionDecl)):
                tempLs.insert(0,i)
                tempLs.insert(1,irl.IRBracket(True))
                finalLs += tempLs
                finalLs.append(irl.IRBracket(False))
                tempLs = []
            else:
                tempLs.append(i)
        for i in finalLs:
            toAdd = irl.IRLine(None)
            toAdd.treeList = [i]
            self.IR.append(toAdd)
        return finalLs

    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in finalLs])

def tokensToString(tokens):
    &#34;&#34;&#34;
    Iterates through the tokens and generates a string of all of them

    Args:
        tokens: The token object that is returned from the lexer.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join([str(x) for x in tokens])


class IR_Lexer():
    &#34;&#34;&#34;
    The lexer class definition to tokenize a gimple IR
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Constructs the Lexer object.
        &#34;&#34;&#34;
        self.lexer = LexerGenerator()

    def _add_tokens(self):
        &#34;&#34;&#34;
        Adds tokens to the rply lexer object
        &#34;&#34;&#34;
        self.lexer.add(&#34;D_NUM&#34;, r&#34;D\.[0-9]*&#34;)
        self.lexer.add(&#34;INT&#34;,r&#34;([1-9]\d*|\d)&#34;)
        self.lexer.add(&#34;FLOAT&#34;,r&#34;(\d|[1-9]\d+)\.\d*&#34;)
        self.lexer.add(&#34;CHAR&#34;,r&#34;\&#39;\\?[\w\;\\ \%\&#34;\&#39;]\&#39;&#34;)
        self.lexer.add(&#34;STRING&#34;,r&#34;(\&#34;[^\n]*?(?&lt;!\\)\&#34;)|(\&#39;[^\n]*?(?&lt;!\\)\&#39;)&#34;)
        self.lexer.add(&#34;PLUS&#34;,r&#34;\+&#34;)
        self.lexer.add(&#34;MINUS&#34;,r&#34;-&#34;)
        self.lexer.add(&#34;DIVIDE&#34;,r&#34;/&#34;)
        self.lexer.add(&#34;TIMES&#34;,r&#34;\*&#34;)
        self.lexer.add(&#34;MODULUS&#34;,r&#34;%&#34;)
        self.lexer.add(&#34;LEFT_SHIFT&#34;,r&#34;&lt;&lt;&#34;)
        self.lexer.add(&#34;RIGHT_SHIFT&#34;,r&#34;&gt;&gt;&#34;)
        self.lexer.add(&#34;NOT_EQUAL_TO&#34;,r&#34;!=&#34;)
        self.lexer.add(&#34;NOT&#34;,r&#34;!&#34;)
        self.lexer.add(&#34;XOR&#34;,r&#34;\^&#34;)
        self.lexer.add(&#34;NEGATE&#34;,r&#34;~&#34;)
        self.lexer.add(&#34;SEMICOLON&#34;,r&#34;;&#34;)
        self.lexer.add(&#34;RETURN&#34;,r&#34;\breturn\b&#34;)
        self.lexer.add(&#34;GOTO&#34;,r&#34;\bgoto\b&#34;)
        self.lexer.add(&#34;IF&#34;,r&#34;\bif\b&#34;)
        self.lexer.add(&#34;ELSE&#34;,r&#34;\belse\b&#34;)
        self.lexer.add(&#34;GEQ&#34;,r&#34;&gt;=&#34;)
        self.lexer.add(&#34;LEQ&#34;,r&#34;&lt;=&#34;)
        self.lexer.add(&#34;GREATER_THAN&#34;,r&#34;&gt;&#34;)
        self.lexer.add(&#34;LESS_THAN&#34;,r&#34;&lt;&#34;)
        self.lexer.add(&#34;EQUAL_TO&#34;,r&#34;={2}&#34;)
        self.lexer.add(&#34;EQUALS&#34;,r&#34;=&#34;)
        self.lexer.add(&#34;NULL&#34;,r&#34;\bNULL\b&#34;)
        self.lexer.add(&#34;KEYWORD&#34;,&#34;\b(const|signed|static|unsigned|extern)\b&#34;)
        self.lexer.add(&#34;COMMA&#34;,r&#34;,&#34;)
        self.lexer.add(&#34;COLON&#34;,r&#34;:&#34;)
        self.lexer.add(&#34;AND&#34;,r&#34;&amp;{2}&#34;)
        self.lexer.add(&#34;OR&#34;,r&#34;\|{2}&#34;)
        self.lexer.add(&#34;BW_AND&#34;,r&#34;&amp;&#34;)
        self.lexer.add(&#34;BW_OR&#34;,r&#34;\|&#34;)
        self.lexer.add(&#34;TYPE&#34;,r&#34;\b(auto|long double|double|float|long long( int)?|long|int|short|char|void)\b&#34;)
        self.lexer.add(&#34;VAR_NAME&#34;,r&#34;tV_[a-zA-Z_]\w*|rV_[a-zA-Z_]\w*&#34;)
        self.lexer.add(&#34;OPEN_PAREN&#34;,r&#34;\(&#34;)
        self.lexer.add(&#34;CLOSE_PAREN&#34;,r&#34;\)&#34;)
        self.lexer.add(&#34;OPEN_BRACK&#34;,r&#34;\{&#34;)
        self.lexer.add(&#34;CLOSE_BRACK&#34;,r&#34;\}&#34;)
        self.lexer.ignore(r&#39;\s+&#39;)
        self.lexer.ignore(r&#39;\n&#39;)
        self.lexer.ignore(r&#39;\t&#39;)


    def get_lexer(self):
        &#34;&#34;&#34;
        Retrieves the lexer, with the tokens added to the inner lexer object.

        Returns:
            The lexer, now built with the tokens added
        &#34;&#34;&#34;
        self._add_tokens()
        return self.lexer.build()

def print_error(token):
    &#34;&#34;&#34;
    Prints lexer error message. Currently we only experience invalid token
    errors. The input `token` is a `Token` object, imported from `rply`.

    Args:
        token: The token object that is returned from the lexer.
    &#34;&#34;&#34;
    print(f&#34;LexingError: Invalid Token \&#39;{token.value}\&#39; at, {token.source_pos}\n&#34;)





&#34;&#34;&#34;
This module contains definitions for the ParseTree and Parser classes, as well as some ansillary functions to assist.
&#34;&#34;&#34;
from rply import ParserGenerator
from rply.errors import ParserGeneratorWarning
from warnings import simplefilter
from rply.token import Token

#we get werid &#39;non-descriptive&#39; warnings from ParserGenerator, this ignores those
simplefilter(&#39;ignore&#39;, ParserGeneratorWarning)

class ParseTree():
    &#34;&#34;&#34;
    ParseTree is a class that acts as each node in an ParseTree
    &#34;&#34;&#34;
    def __init__(self, token, content):
        &#34;&#34;&#34;
        Construct a new ParseTree object

        Args:
            token: The token type of the node.
            content: The content of that is tokenized.
        &#34;&#34;&#34;
        self.token = token
        self.content = content

    def print_ParseTree(self, file=None, _prefix=&#34;&#34;, _last=True):
        &#34;&#34;&#34;
        Prints the ParseTree in depth first order

        Args:
            file: The file to be written to (Defaults to Stdout).
            _prefix: A string indicating the spacing from the left side of the screen.
            _last: A boolean that indicates if a self is the last in it&#39;s immediate surroundings.
        &#34;&#34;&#34;
        print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{self.token}&#34;, file=file)
        _prefix += &#34;    &#34; if _last else &#34;|   &#34;
        for i, child in enumerate(self.content):
            _last = i == len(self.content)-1
            if &#39;content&#39; in child.__dict__:
                child.print_ParseTree(file, _prefix, _last)
            else:
                print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{child}&#34;, file=file)

    def __str__(self):
        &#34;&#34;&#34;
        Produces a string representation of the Parse Tree
        &#34;&#34;&#34;
        li = []

        ntv = [(&#34;&#34;, self, True)]

        while ntv:
            li.append(ntv[0])

            ntv = [(f&#34;{ntv[0][0]}{&#39;    &#39; if ntv[0][2] else &#39;|   &#39;}&#34;, x, i == len(ntv[0][1].content)-1 ) for i, x in enumerate(ntv[0][1].content)] + ntv[1:] if &#39;content&#39; in ntv[0][1].__dict__ else ntv[1:]

        return &#34;&#34;.join([f&#34;{x[0]}{&#39;`-- &#39; if x[2] else &#39;|-- &#39;}{x[1].token if &#39;token&#39; in x[1].__dict__ else x[1]}&#34; for x in li]) + &#34;&#34;

    def __repr__(self):
        &#34;&#34;&#34;
        Constructs a list based string representation of the parse tree
        &#34;&#34;&#34;

        li = []

        ntv = [(1, self)]

        while ntv:
            li.append((ntv[0][0], ntv[0][1].content))

            ntv = [(ntv[0][0]+1, x) for x in ntv[0][1].content if &#39;content&#39; in x.__dict__] + ntv[1:]

        return &#34;&#34;.join([f&#34;{x[0]} : {[y.token if &#39;content&#39; in y.__dict__ else y for y in x[1]]}&#34; for x in li])

    def getListView(self, level):
        &#34;&#34;&#34;
        Prints a simple list version of the tree for output. Calls itself recursively

        Args:
            level: The current level of the tree.
        &#34;&#34;&#34;

        li = []
        li.append(f&#34;{level+1} : {[x if &#39;content&#39; not in x.__dict__ else x.token for x in self.content]}&#34;)

        for x in self.content:
            if &#34;content&#34; in x.__dict__:
                li.extend(x.getListView(level+1))

        if level == 0:
            return &#34;&#34;.join(li)
        return li

#setup parser class
class Parser():
    &#34;&#34;&#34;
    Definition for the Parser object, works off of rply. Contains rules for parsing a gimple IR.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the parser and tells it the allowed tokens

        &#34;&#34;&#34;

        self.pg = ParserGenerator(
            [&#39;PROGRAM&#39;,&#39;VAR_NAME&#39;,&#39;OPEN_PAREN&#39;,&#39;CLOSE_PAREN&#39;,&#39;OPEN_BRACK&#39;,&#39;CLOSE_BRACK&#39;,&#39;FUNCTION_DEF&#39;,&#39;TYPE&#39;,&#39;COMMA&#39;,&#39;PARAMATERS&#39;,&#39;PARAMETERS&#39;,&#39;CONTENT&#39;,&#39;D_NUM&#39;,&#39;SEMICOLON&#39;,&#39;LINE&#39;,&#39;EQUALS&#39;,&#39;STRING&#39;,&#39;CHAR&#39;,&#39;MINUS&#39;,&#39;PLUS&#39;,&#39;NEGATE&#39;,&#39;NOT&#39;,&#39;NULL&#39;,&#39;RETURN&#39;,&#39;IF&#39;,&#39;GOTO&#39;,&#39;LESS_THAN&#39;,&#39;GREATER_THAN&#39;,&#39;ELSE&#39;,&#39;COLON&#39;,&#39;KEWORD&#39;,&#39;CONDITION&#39;,&#39;FUNC_CALL&#39;,&#39;FUNC_INPUT&#39;,&#39;COMP&#39;,&#39;EQUAL_TO&#39;,&#39;LEQ&#39;,&#39;GEQ&#39;,&#39;NOT_EQUAL_TO&#39;,&#39;OP&#39;,&#39;DIVIDE&#39;,&#39;TIMES&#39;,&#39;MODULUS&#39;,&#39;BW_AND&#39;,&#39;BW_OR&#39;,&#39;LEFT_SHIFT&#39;,&#39;RIGHT_SHIFT&#39;,&#39;XOR&#39;,&#39;INT&#39;,&#39;DIG&#39;,&#39;FLOAT&#39;] ,
        )
        #initialzie head and current node
        self.Head = None
        self.ls = []


    def parse(self):
        &#34;&#34;&#34;
        The list of BNF functions and their behavior for the gimple IR.
        &#34;&#34;&#34;

        @self.pg.production(&#39;program : function_def &#39;)
        def program___function_def_(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;program : function_def program &#39;)
        def program___function_def_program_(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;program :  &#39;)
        def program____(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;function_def : VAR_NAME OPEN_PAREN parameters CLOSE_PAREN OPEN_BRACK content CLOSE_BRACK &#39;)
        def function_def___VAR_NAME_OPEN_PAREN_parameters_CLOSE_PAREN_OPEN_BRACK_content_CLOSE_BRACK_(p):

            newNode = ParseTree(&#34;FUNCTION_DEF&#34;,p)
            self.Head = newNode
            #first, convert parameters to a string form
            #also, get the string representation of VAR_NAME

            tokens = []
            tokens += [x.value for x in p[2].content if isinstance(x,Token)]
            tokenSets = [x for x in p[2].content if isinstance(x,ParseTree)]
            while tokenSets != []:
                for i in tokenSets:
                    tokens += [x.value for x in i.content if isinstance(x,Token)]
                    tokenSets = [x for x in i.content if isinstance(x,ParseTree)]


            functioName = p[0].value
            params = &#34; &#34;.join(tokens)
            IRNodeToReturn = irl.IRFunctionDecl(functioName,params)
            self.ls.append(IRNodeToReturn)
            return newNode

        @self.pg.production(&#39;parameters : TYPE VAR_NAME COMMA parameters &#39;)
        def parameters___TYPE_VAR_NAME_COMMA_parameters_(p):
            newNode = ParseTree(&#34;PARAMATERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;parameters : TYPE VAR_NAME &#39;)
        def parameters___TYPE_VAR_NAME_(p):
            newNode = ParseTree(&#34;PARAMETERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;parameters : &#39;)
        def parameters___(p):
            newNode = ParseTree(&#34;PARAMETERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : line &#39;)
        def content___line_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : content content &#39;)
        def content___content_content_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : &#39;)
        def content___(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : OPEN_BRACK content CLOSE_BRACK &#39;)
        def content___OPEN_BRACK_content_CLOSE_BRACK_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;line : TYPE D_NUM SEMICOLON &#39;)
        def line___TYPE_D_NUM_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            typ = p[0]
            name = p[1]
            IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
            self.ls.append(IRNodeToReturn)

            return newNode

        @self.pg.production(&#39;line : TYPE VAR_NAME SEMICOLON &#39;)
        def line___TYPE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #needs modifiers, type, and varname
            #modifiers is none
            typ = p[0]
            name = p[1]
            IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
            self.ls.append(IRNodeToReturn)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig op dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_op_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].content[0].value
            rhs = p[4].content[0].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].content[0].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS STRING SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_STRING_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS CHAR SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_CHAR_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_op_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].value
            rhs = p[4].content[0].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig op VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_op_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].content[0].value
            rhs = p[4].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_op_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].value
            rhs = p[4].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_MINUS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_MINUS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_PLUS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_PLUS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NEGATE_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NOT dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NOT_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NOT VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NOT_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NEGATE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NULL SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NULL_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS VAR_NAME SEMICOLON &#39;)
        def line___D_NUM_EQUALS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS dig SEMICOLON &#39;)
        def line___D_NUM_EQUALS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].content[0].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS STRING SEMICOLON &#39;)
        def line___D_NUM_EQUALS_STRING_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS CHAR SEMICOLON &#39;)
        def line___D_NUM_EQUALS_CHAR_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : RETURN D_NUM SEMICOLON &#39;)
        def line___RETURN_D_NUM_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #just needs value, should be p[1]
            value = p[1].value
            NodeToBeReturned = irl.IRReturn(value)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : func_call SEMICOLON &#39;)
        def line___func_call_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            func_name = p[0].content[0].value
            contentList = p[0].content[2]
            params = []
            while contentList != []:
                # print(&#34;SJSD&#34;)
                params.append(contentList.content[0].value)
                if(len(contentList.content) == 3):
                    contentList = contentList.content[2]
                else:
                    contentList =[]
            #NEED TO IDENTIF WHAT IR NODE THIS BECOMES, WE HAVE THE PARAMS AND THE NAME
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS func_call SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_func_call_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            func_name = p[2].content[0].value
            contentList = p[2].content[2]
            params = []
            lhs = p[0].value
            while contentList != []:
                params.append(contentList.content[0].value)
                if(len(contentList.content) == 3):
                    contentList = contentList.content[2]
                else:
                    contentList =[]
            IRNodeToBeReturned = irl.IRFunctionAssign(None,None,None)
            IRNodeToBeReturned.LineFromFile(lhs,func_name,params)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : IF OPEN_PAREN condition CLOSE_PAREN GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON ELSE GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
        def line___IF_OPEN_PAREN_condition_CLOSE_PAREN_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_ELSE_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[2].content[0].value
            rhs = p[2].content[2].value
            compOp = p[2].content[1].content[0].value
            succ = p[6].value.split(&#34;.&#34;)[1]
            fail = p[12].value.split(&#34;.&#34;)[1]
            IRNodeToBeReturned = irl.IRIf(None,None,None,None)
            IRNodeToBeReturned.fileInit(lhs,rhs,compOp,succ,fail)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : LESS_THAN D_NUM GREATER_THAN COLON &#39;)
        def line___LESS_THAN_D_NUM_GREATER_THAN_COLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #name of the label
            nameLabel = p[1].value
            IRNodeToBeReturned = irl.IRJump(nameLabel)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
        def line___GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            name = &#34;&#34;.join([p[1].value, p[2].value, p[3].value])
            IRNodeToBeReturned = irl.IRGoTo(name)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : GOTO VAR_NAME SEMICOLON &#39;)
        def line___GOTO_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            name = p[1].value
            IRNodeToBeReturned = irl.IRGoTo(name)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME COLON &#39;)
        def line___VAR_NAME_COLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            nameLabel = p[0].value
            IRNodeToBeReturned = irl.IRJump(nameLabel)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : KEWORD TYPE VAR_NAME SEMICOLON &#39;)
        def line___KEWORD_TYPE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;line : RETURN SEMICOLON &#39;)
        def line___RETURN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            value = &#34;&#34;
            NodeToBeReturned = irl.IRReturn(value)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;condition : VAR_NAME comp VAR_NAME &#39;)
        def condition___VAR_NAME_comp_VAR_NAME_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : VAR_NAME comp dig &#39;)
        def condition___VAR_NAME_comp_dig_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : dig comp dig &#39;)
        def condition___dig_comp_dig_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : dig comp VAR_NAME &#39;)
        def condition___dig_comp_VAR_NAME_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_call : VAR_NAME OPEN_PAREN func_input CLOSE_PAREN &#39;)
        def func_call___VAR_NAME_OPEN_PAREN_func_input_CLOSE_PAREN_(p):
            newNode = ParseTree(&#34;FUNC_CALL&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : &#39;)
        def func_input___(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : STRING COMMA func_input &#39;)
        def func_input___STRING_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : CHAR COMMA func_input &#39;)
        def func_input___CHAR_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : dig COMMA func_input &#39;)
        def func_input___dig_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : VAR_NAME COMMA func_input &#39;)
        def func_input___VAR_NAME_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : STRING  &#39;)
        def func_input___STRING__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : CHAR  &#39;)
        def func_input___CHAR__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : dig  &#39;)
        def func_input___dig__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : VAR_NAME &#39;)
        def func_input___VAR_NAME_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : LESS_THAN &#39;)
        def comp___LESS_THAN_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : GREATER_THAN &#39;)
        def comp___GREATER_THAN_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : EQUAL_TO &#39;)
        def comp___EQUAL_TO_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : LEQ &#39;)
        def comp___LEQ_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : GEQ &#39;)
        def comp___GEQ_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : NOT_EQUAL_TO &#39;)
        def comp___NOT_EQUAL_TO_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : PLUS &#39;)
        def op___PLUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : MINUS &#39;)
        def op___MINUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : DIVIDE &#39;)
        def op___DIVIDE_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : TIMES &#39;)
        def op___TIMES_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : MODULUS &#39;)
        def op___MODULUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : BW_AND &#39;)
        def op___BW_AND_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : BW_OR &#39;)
        def op___BW_OR_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : NEGATE &#39;)
        def op___NEGATE_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : LEFT_SHIFT &#39;)
        def op___LEFT_SHIFT_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : RIGHT_SHIFT &#39;)
        def op___RIGHT_SHIFT_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : XOR &#39;)
        def op___XOR_(p):
            newNode = ParseTree(&#34;&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;dig : INT &#39;)
        def dig___INT_(p):
            newNode = ParseTree(&#34;DIG&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;dig : FLOAT &#39;)
        def dig___FLOAT_(p):
            newNode = ParseTree(&#34;DIG&#34;,p)
            self.Head = newNode
            return newNode


        @self.pg.error
        def error_handle(token):
            &#34;&#34;&#34;
            Boilerplate error handling function

            Args:
                token: The token that caused an error.
            &#34;&#34;&#34;
            return ValueError(token)

    #boilerplate function
    def get_parser(self):
        &#34;&#34;&#34;
        Retrieves the built version of the parser.

        Returns:
            The built parser.
        &#34;&#34;&#34;
        return self.pg.build()

    #retrieve the trees head
    def getTree(self):
        &#34;&#34;&#34;
        Getter for the head of the tree.

        Returns:
            The head of the tree.
        &#34;&#34;&#34;

        return self.Head

    def print_error(self):
        &#34;&#34;&#34;
        Prints parser error message. This function ultimately iterates through the ParseTree that was returned after the parser found an error. ParseTree&#39;s consist of tokens as well as other ParseTree&#39;s so we need to iterate to find the first token and then print its source position.
        &#34;&#34;&#34;
        # TODO: add some more in-depth error processing to print
        # out a more detailed description of what went wrong, and possibly some suggestions
        # at to why there was a parse/syntax error. (i.e. suggest a missing semicolon)

        head = self.getTree()
        token = 0 # token hasn&#39;t been found yet, so we set value to 0

        while True and head:
            # Iterate through list of elements
            for i in head.content:

                # Could be a Token
                if(type(i) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):

                    # Found a Token
                    token = i
                    break

            # Check again (to break out of while loop and not iterate again)
            if (type(token) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):
                break
            else:
                # Set head to last element.
                # If this code executes then I can assume that the
                # last element is an ParseTree.
                head = head.content[len(head.content)-1]

        if token:
            print(f&#34;ParsingError: Last token  \&#39;{token.value}\&#39; parsed successfully at, {token.source_pos}\n&#34;)
        else:
            # Never found a token to report, need to exit
            print(&#34;ParsingError: No ParseTree obtained\n&#34;)
            exit()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.optimizer.import_ir.print_error"><code class="name flex">
<span>def <span class="ident">print_error</span></span>(<span>token)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints lexer error message. Currently we only experience invalid token
errors. The input <code>token</code> is a <code>Token</code> object, imported from <code>rply</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong></dt>
<dd>The token object that is returned from the lexer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_error(token):
    &#34;&#34;&#34;
    Prints lexer error message. Currently we only experience invalid token
    errors. The input `token` is a `Token` object, imported from `rply`.

    Args:
        token: The token object that is returned from the lexer.
    &#34;&#34;&#34;
    print(f&#34;LexingError: Invalid Token \&#39;{token.value}\&#39; at, {token.source_pos}\n&#34;)</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.tokensToString"><code class="name flex">
<span>def <span class="ident">tokensToString</span></span>(<span>tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Iterates through the tokens and generates a string of all of them</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tokens</code></strong></dt>
<dd>The token object that is returned from the lexer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokensToString(tokens):
    &#34;&#34;&#34;
    Iterates through the tokens and generates a string of all of them

    Args:
        tokens: The token object that is returned from the lexer.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join([str(x) for x in tokens])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.optimizer.import_ir.IR_Lexer"><code class="flex name class">
<span>class <span class="ident">IR_Lexer</span></span>
</code></dt>
<dd>
<section class="desc"><p>The lexer class definition to tokenize a gimple IR</p>
<p>Constructs the Lexer object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IR_Lexer():
    &#34;&#34;&#34;
    The lexer class definition to tokenize a gimple IR
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Constructs the Lexer object.
        &#34;&#34;&#34;
        self.lexer = LexerGenerator()

    def _add_tokens(self):
        &#34;&#34;&#34;
        Adds tokens to the rply lexer object
        &#34;&#34;&#34;
        self.lexer.add(&#34;D_NUM&#34;, r&#34;D\.[0-9]*&#34;)
        self.lexer.add(&#34;INT&#34;,r&#34;([1-9]\d*|\d)&#34;)
        self.lexer.add(&#34;FLOAT&#34;,r&#34;(\d|[1-9]\d+)\.\d*&#34;)
        self.lexer.add(&#34;CHAR&#34;,r&#34;\&#39;\\?[\w\;\\ \%\&#34;\&#39;]\&#39;&#34;)
        self.lexer.add(&#34;STRING&#34;,r&#34;(\&#34;[^\n]*?(?&lt;!\\)\&#34;)|(\&#39;[^\n]*?(?&lt;!\\)\&#39;)&#34;)
        self.lexer.add(&#34;PLUS&#34;,r&#34;\+&#34;)
        self.lexer.add(&#34;MINUS&#34;,r&#34;-&#34;)
        self.lexer.add(&#34;DIVIDE&#34;,r&#34;/&#34;)
        self.lexer.add(&#34;TIMES&#34;,r&#34;\*&#34;)
        self.lexer.add(&#34;MODULUS&#34;,r&#34;%&#34;)
        self.lexer.add(&#34;LEFT_SHIFT&#34;,r&#34;&lt;&lt;&#34;)
        self.lexer.add(&#34;RIGHT_SHIFT&#34;,r&#34;&gt;&gt;&#34;)
        self.lexer.add(&#34;NOT_EQUAL_TO&#34;,r&#34;!=&#34;)
        self.lexer.add(&#34;NOT&#34;,r&#34;!&#34;)
        self.lexer.add(&#34;XOR&#34;,r&#34;\^&#34;)
        self.lexer.add(&#34;NEGATE&#34;,r&#34;~&#34;)
        self.lexer.add(&#34;SEMICOLON&#34;,r&#34;;&#34;)
        self.lexer.add(&#34;RETURN&#34;,r&#34;\breturn\b&#34;)
        self.lexer.add(&#34;GOTO&#34;,r&#34;\bgoto\b&#34;)
        self.lexer.add(&#34;IF&#34;,r&#34;\bif\b&#34;)
        self.lexer.add(&#34;ELSE&#34;,r&#34;\belse\b&#34;)
        self.lexer.add(&#34;GEQ&#34;,r&#34;&gt;=&#34;)
        self.lexer.add(&#34;LEQ&#34;,r&#34;&lt;=&#34;)
        self.lexer.add(&#34;GREATER_THAN&#34;,r&#34;&gt;&#34;)
        self.lexer.add(&#34;LESS_THAN&#34;,r&#34;&lt;&#34;)
        self.lexer.add(&#34;EQUAL_TO&#34;,r&#34;={2}&#34;)
        self.lexer.add(&#34;EQUALS&#34;,r&#34;=&#34;)
        self.lexer.add(&#34;NULL&#34;,r&#34;\bNULL\b&#34;)
        self.lexer.add(&#34;KEYWORD&#34;,&#34;\b(const|signed|static|unsigned|extern)\b&#34;)
        self.lexer.add(&#34;COMMA&#34;,r&#34;,&#34;)
        self.lexer.add(&#34;COLON&#34;,r&#34;:&#34;)
        self.lexer.add(&#34;AND&#34;,r&#34;&amp;{2}&#34;)
        self.lexer.add(&#34;OR&#34;,r&#34;\|{2}&#34;)
        self.lexer.add(&#34;BW_AND&#34;,r&#34;&amp;&#34;)
        self.lexer.add(&#34;BW_OR&#34;,r&#34;\|&#34;)
        self.lexer.add(&#34;TYPE&#34;,r&#34;\b(auto|long double|double|float|long long( int)?|long|int|short|char|void)\b&#34;)
        self.lexer.add(&#34;VAR_NAME&#34;,r&#34;tV_[a-zA-Z_]\w*|rV_[a-zA-Z_]\w*&#34;)
        self.lexer.add(&#34;OPEN_PAREN&#34;,r&#34;\(&#34;)
        self.lexer.add(&#34;CLOSE_PAREN&#34;,r&#34;\)&#34;)
        self.lexer.add(&#34;OPEN_BRACK&#34;,r&#34;\{&#34;)
        self.lexer.add(&#34;CLOSE_BRACK&#34;,r&#34;\}&#34;)
        self.lexer.ignore(r&#39;\s+&#39;)
        self.lexer.ignore(r&#39;\n&#39;)
        self.lexer.ignore(r&#39;\t&#39;)


    def get_lexer(self):
        &#34;&#34;&#34;
        Retrieves the lexer, with the tokens added to the inner lexer object.

        Returns:
            The lexer, now built with the tokens added
        &#34;&#34;&#34;
        self._add_tokens()
        return self.lexer.build()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.import_ir.IR_Lexer.get_lexer"><code class="name flex">
<span>def <span class="ident">get_lexer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the lexer, with the tokens added to the inner lexer object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>lexer</code>, <code>now</code> <code>built</code> <code>with</code> <code>the</code> <code>tokens</code> <code>added</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lexer(self):
    &#34;&#34;&#34;
    Retrieves the lexer, with the tokens added to the inner lexer object.

    Returns:
        The lexer, now built with the tokens added
    &#34;&#34;&#34;
    self._add_tokens()
    return self.lexer.build()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.import_ir.ParseTree"><code class="flex name class">
<span>class <span class="ident">ParseTree</span></span>
<span>(</span><span>token, content)</span>
</code></dt>
<dd>
<section class="desc"><p>ParseTree is a class that acts as each node in an ParseTree</p>
<p>Construct a new ParseTree object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong></dt>
<dd>The token type of the node.</dd>
<dt><strong><code>content</code></strong></dt>
<dd>The content of that is tokenized.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParseTree():
    &#34;&#34;&#34;
    ParseTree is a class that acts as each node in an ParseTree
    &#34;&#34;&#34;
    def __init__(self, token, content):
        &#34;&#34;&#34;
        Construct a new ParseTree object

        Args:
            token: The token type of the node.
            content: The content of that is tokenized.
        &#34;&#34;&#34;
        self.token = token
        self.content = content

    def print_ParseTree(self, file=None, _prefix=&#34;&#34;, _last=True):
        &#34;&#34;&#34;
        Prints the ParseTree in depth first order

        Args:
            file: The file to be written to (Defaults to Stdout).
            _prefix: A string indicating the spacing from the left side of the screen.
            _last: A boolean that indicates if a self is the last in it&#39;s immediate surroundings.
        &#34;&#34;&#34;
        print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{self.token}&#34;, file=file)
        _prefix += &#34;    &#34; if _last else &#34;|   &#34;
        for i, child in enumerate(self.content):
            _last = i == len(self.content)-1
            if &#39;content&#39; in child.__dict__:
                child.print_ParseTree(file, _prefix, _last)
            else:
                print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{child}&#34;, file=file)

    def __str__(self):
        &#34;&#34;&#34;
        Produces a string representation of the Parse Tree
        &#34;&#34;&#34;
        li = []

        ntv = [(&#34;&#34;, self, True)]

        while ntv:
            li.append(ntv[0])

            ntv = [(f&#34;{ntv[0][0]}{&#39;    &#39; if ntv[0][2] else &#39;|   &#39;}&#34;, x, i == len(ntv[0][1].content)-1 ) for i, x in enumerate(ntv[0][1].content)] + ntv[1:] if &#39;content&#39; in ntv[0][1].__dict__ else ntv[1:]

        return &#34;&#34;.join([f&#34;{x[0]}{&#39;`-- &#39; if x[2] else &#39;|-- &#39;}{x[1].token if &#39;token&#39; in x[1].__dict__ else x[1]}&#34; for x in li]) + &#34;&#34;

    def __repr__(self):
        &#34;&#34;&#34;
        Constructs a list based string representation of the parse tree
        &#34;&#34;&#34;

        li = []

        ntv = [(1, self)]

        while ntv:
            li.append((ntv[0][0], ntv[0][1].content))

            ntv = [(ntv[0][0]+1, x) for x in ntv[0][1].content if &#39;content&#39; in x.__dict__] + ntv[1:]

        return &#34;&#34;.join([f&#34;{x[0]} : {[y.token if &#39;content&#39; in y.__dict__ else y for y in x[1]]}&#34; for x in li])

    def getListView(self, level):
        &#34;&#34;&#34;
        Prints a simple list version of the tree for output. Calls itself recursively

        Args:
            level: The current level of the tree.
        &#34;&#34;&#34;

        li = []
        li.append(f&#34;{level+1} : {[x if &#39;content&#39; not in x.__dict__ else x.token for x in self.content]}&#34;)

        for x in self.content:
            if &#34;content&#34; in x.__dict__:
                li.extend(x.getListView(level+1))

        if level == 0:
            return &#34;&#34;.join(li)
        return li</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.import_ir.ParseTree.getListView"><code class="name flex">
<span>def <span class="ident">getListView</span></span>(<span>self, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints a simple list version of the tree for output. Calls itself recursively</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong></dt>
<dd>The current level of the tree.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getListView(self, level):
    &#34;&#34;&#34;
    Prints a simple list version of the tree for output. Calls itself recursively

    Args:
        level: The current level of the tree.
    &#34;&#34;&#34;

    li = []
    li.append(f&#34;{level+1} : {[x if &#39;content&#39; not in x.__dict__ else x.token for x in self.content]}&#34;)

    for x in self.content:
        if &#34;content&#34; in x.__dict__:
            li.extend(x.getListView(level+1))

    if level == 0:
        return &#34;&#34;.join(li)
    return li</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.ParseTree.print_ParseTree"><code class="name flex">
<span>def <span class="ident">print_ParseTree</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints the ParseTree in depth first order</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The file to be written to (Defaults to Stdout).</dd>
<dt><strong><code>_prefix</code></strong></dt>
<dd>A string indicating the spacing from the left side of the screen.</dd>
<dt><strong><code>_last</code></strong></dt>
<dd>A boolean that indicates if a self is the last in it's immediate surroundings.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_ParseTree(self, file=None, _prefix=&#34;&#34;, _last=True):
    &#34;&#34;&#34;
    Prints the ParseTree in depth first order

    Args:
        file: The file to be written to (Defaults to Stdout).
        _prefix: A string indicating the spacing from the left side of the screen.
        _last: A boolean that indicates if a self is the last in it&#39;s immediate surroundings.
    &#34;&#34;&#34;
    print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{self.token}&#34;, file=file)
    _prefix += &#34;    &#34; if _last else &#34;|   &#34;
    for i, child in enumerate(self.content):
        _last = i == len(self.content)-1
        if &#39;content&#39; in child.__dict__:
            child.print_ParseTree(file, _prefix, _last)
        else:
            print(f&#34;{_prefix}{&#39;`-- &#39; if _last else &#39;|-- &#39;}{child}&#34;, file=file)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.import_ir.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
</code></dt>
<dd>
<section class="desc"><p>Definition for the Parser object, works off of rply. Contains rules for parsing a gimple IR.</p>
<p>Initializes the parser and tells it the allowed tokens</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parser():
    &#34;&#34;&#34;
    Definition for the Parser object, works off of rply. Contains rules for parsing a gimple IR.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the parser and tells it the allowed tokens

        &#34;&#34;&#34;

        self.pg = ParserGenerator(
            [&#39;PROGRAM&#39;,&#39;VAR_NAME&#39;,&#39;OPEN_PAREN&#39;,&#39;CLOSE_PAREN&#39;,&#39;OPEN_BRACK&#39;,&#39;CLOSE_BRACK&#39;,&#39;FUNCTION_DEF&#39;,&#39;TYPE&#39;,&#39;COMMA&#39;,&#39;PARAMATERS&#39;,&#39;PARAMETERS&#39;,&#39;CONTENT&#39;,&#39;D_NUM&#39;,&#39;SEMICOLON&#39;,&#39;LINE&#39;,&#39;EQUALS&#39;,&#39;STRING&#39;,&#39;CHAR&#39;,&#39;MINUS&#39;,&#39;PLUS&#39;,&#39;NEGATE&#39;,&#39;NOT&#39;,&#39;NULL&#39;,&#39;RETURN&#39;,&#39;IF&#39;,&#39;GOTO&#39;,&#39;LESS_THAN&#39;,&#39;GREATER_THAN&#39;,&#39;ELSE&#39;,&#39;COLON&#39;,&#39;KEWORD&#39;,&#39;CONDITION&#39;,&#39;FUNC_CALL&#39;,&#39;FUNC_INPUT&#39;,&#39;COMP&#39;,&#39;EQUAL_TO&#39;,&#39;LEQ&#39;,&#39;GEQ&#39;,&#39;NOT_EQUAL_TO&#39;,&#39;OP&#39;,&#39;DIVIDE&#39;,&#39;TIMES&#39;,&#39;MODULUS&#39;,&#39;BW_AND&#39;,&#39;BW_OR&#39;,&#39;LEFT_SHIFT&#39;,&#39;RIGHT_SHIFT&#39;,&#39;XOR&#39;,&#39;INT&#39;,&#39;DIG&#39;,&#39;FLOAT&#39;] ,
        )
        #initialzie head and current node
        self.Head = None
        self.ls = []


    def parse(self):
        &#34;&#34;&#34;
        The list of BNF functions and their behavior for the gimple IR.
        &#34;&#34;&#34;

        @self.pg.production(&#39;program : function_def &#39;)
        def program___function_def_(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;program : function_def program &#39;)
        def program___function_def_program_(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;program :  &#39;)
        def program____(p):
            newNode = ParseTree(&#34;PROGRAM&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;function_def : VAR_NAME OPEN_PAREN parameters CLOSE_PAREN OPEN_BRACK content CLOSE_BRACK &#39;)
        def function_def___VAR_NAME_OPEN_PAREN_parameters_CLOSE_PAREN_OPEN_BRACK_content_CLOSE_BRACK_(p):

            newNode = ParseTree(&#34;FUNCTION_DEF&#34;,p)
            self.Head = newNode
            #first, convert parameters to a string form
            #also, get the string representation of VAR_NAME

            tokens = []
            tokens += [x.value for x in p[2].content if isinstance(x,Token)]
            tokenSets = [x for x in p[2].content if isinstance(x,ParseTree)]
            while tokenSets != []:
                for i in tokenSets:
                    tokens += [x.value for x in i.content if isinstance(x,Token)]
                    tokenSets = [x for x in i.content if isinstance(x,ParseTree)]


            functioName = p[0].value
            params = &#34; &#34;.join(tokens)
            IRNodeToReturn = irl.IRFunctionDecl(functioName,params)
            self.ls.append(IRNodeToReturn)
            return newNode

        @self.pg.production(&#39;parameters : TYPE VAR_NAME COMMA parameters &#39;)
        def parameters___TYPE_VAR_NAME_COMMA_parameters_(p):
            newNode = ParseTree(&#34;PARAMATERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;parameters : TYPE VAR_NAME &#39;)
        def parameters___TYPE_VAR_NAME_(p):
            newNode = ParseTree(&#34;PARAMETERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;parameters : &#39;)
        def parameters___(p):
            newNode = ParseTree(&#34;PARAMETERS&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : line &#39;)
        def content___line_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : content content &#39;)
        def content___content_content_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : &#39;)
        def content___(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;content : OPEN_BRACK content CLOSE_BRACK &#39;)
        def content___OPEN_BRACK_content_CLOSE_BRACK_(p):
            newNode = ParseTree(&#34;CONTENT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;line : TYPE D_NUM SEMICOLON &#39;)
        def line___TYPE_D_NUM_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            typ = p[0]
            name = p[1]
            IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
            self.ls.append(IRNodeToReturn)

            return newNode

        @self.pg.production(&#39;line : TYPE VAR_NAME SEMICOLON &#39;)
        def line___TYPE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #needs modifiers, type, and varname
            #modifiers is none
            typ = p[0]
            name = p[1]
            IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
            self.ls.append(IRNodeToReturn)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig op dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_op_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].content[0].value
            rhs = p[4].content[0].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].content[0].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS STRING SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_STRING_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS CHAR SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_CHAR_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_op_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].value
            rhs = p[4].content[0].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS dig op VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_dig_op_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].content[0].value
            rhs = p[4].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_VAR_NAME_op_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = p[2].value
            rhs = p[4].value
            op = p[3].content[0].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_MINUS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_MINUS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_PLUS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_PLUS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = 0
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NEGATE_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NOT dig SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NOT_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].content[0].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NOT VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NOT_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode

            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE VAR_NAME SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NEGATE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            IRNodeToBeReturned = irl.IRArth(None,None,None)
            varName = p[0].value
            lhs = &#34;&#34;
            rhs = p[3].value
            op = p[2].value

            IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS NULL SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_NULL_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS VAR_NAME SEMICOLON &#39;)
        def line___D_NUM_EQUALS_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS dig SEMICOLON &#39;)
        def line___D_NUM_EQUALS_dig_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].content[0].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS STRING SEMICOLON &#39;)
        def line___D_NUM_EQUALS_STRING_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : D_NUM EQUALS CHAR SEMICOLON &#39;)
        def line___D_NUM_EQUALS_CHAR_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[0].value
            rhs = p[2].value
            NodeToBeReturned = irl.IRAssignment(lhs,rhs)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : RETURN D_NUM SEMICOLON &#39;)
        def line___RETURN_D_NUM_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #just needs value, should be p[1]
            value = p[1].value
            NodeToBeReturned = irl.IRReturn(value)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : func_call SEMICOLON &#39;)
        def line___func_call_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            func_name = p[0].content[0].value
            contentList = p[0].content[2]
            params = []
            while contentList != []:
                # print(&#34;SJSD&#34;)
                params.append(contentList.content[0].value)
                if(len(contentList.content) == 3):
                    contentList = contentList.content[2]
                else:
                    contentList =[]
            #NEED TO IDENTIF WHAT IR NODE THIS BECOMES, WE HAVE THE PARAMS AND THE NAME
            return newNode

        @self.pg.production(&#39;line : VAR_NAME EQUALS func_call SEMICOLON &#39;)
        def line___VAR_NAME_EQUALS_func_call_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            func_name = p[2].content[0].value
            contentList = p[2].content[2]
            params = []
            lhs = p[0].value
            while contentList != []:
                params.append(contentList.content[0].value)
                if(len(contentList.content) == 3):
                    contentList = contentList.content[2]
                else:
                    contentList =[]
            IRNodeToBeReturned = irl.IRFunctionAssign(None,None,None)
            IRNodeToBeReturned.LineFromFile(lhs,func_name,params)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : IF OPEN_PAREN condition CLOSE_PAREN GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON ELSE GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
        def line___IF_OPEN_PAREN_condition_CLOSE_PAREN_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_ELSE_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            lhs = p[2].content[0].value
            rhs = p[2].content[2].value
            compOp = p[2].content[1].content[0].value
            succ = p[6].value.split(&#34;.&#34;)[1]
            fail = p[12].value.split(&#34;.&#34;)[1]
            IRNodeToBeReturned = irl.IRIf(None,None,None,None)
            IRNodeToBeReturned.fileInit(lhs,rhs,compOp,succ,fail)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : LESS_THAN D_NUM GREATER_THAN COLON &#39;)
        def line___LESS_THAN_D_NUM_GREATER_THAN_COLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            #name of the label
            nameLabel = p[1].value
            IRNodeToBeReturned = irl.IRJump(nameLabel)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
        def line___GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            name = &#34;&#34;.join([p[1].value, p[2].value, p[3].value])
            IRNodeToBeReturned = irl.IRGoTo(name)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : GOTO VAR_NAME SEMICOLON &#39;)
        def line___GOTO_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            name = p[1].value
            IRNodeToBeReturned = irl.IRGoTo(name)
            self.ls.append(IRNodeToBeReturned)
            return newNode

        @self.pg.production(&#39;line : VAR_NAME COLON &#39;)
        def line___VAR_NAME_COLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            nameLabel = p[0].value
            IRNodeToBeReturned = irl.IRJump(nameLabel)
            self.ls.append(IRNodeToBeReturned)

            return newNode

        @self.pg.production(&#39;line : KEWORD TYPE VAR_NAME SEMICOLON &#39;)
        def line___KEWORD_TYPE_VAR_NAME_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;line : RETURN SEMICOLON &#39;)
        def line___RETURN_SEMICOLON_(p):
            newNode = ParseTree(&#34;LINE&#34;,p)
            self.Head = newNode
            value = &#34;&#34;
            NodeToBeReturned = irl.IRReturn(value)
            self.ls.append(NodeToBeReturned)
            return newNode

        @self.pg.production(&#39;condition : VAR_NAME comp VAR_NAME &#39;)
        def condition___VAR_NAME_comp_VAR_NAME_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : VAR_NAME comp dig &#39;)
        def condition___VAR_NAME_comp_dig_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : dig comp dig &#39;)
        def condition___dig_comp_dig_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;condition : dig comp VAR_NAME &#39;)
        def condition___dig_comp_VAR_NAME_(p):
            newNode = ParseTree(&#34;CONDITION&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_call : VAR_NAME OPEN_PAREN func_input CLOSE_PAREN &#39;)
        def func_call___VAR_NAME_OPEN_PAREN_func_input_CLOSE_PAREN_(p):
            newNode = ParseTree(&#34;FUNC_CALL&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : &#39;)
        def func_input___(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : STRING COMMA func_input &#39;)
        def func_input___STRING_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : CHAR COMMA func_input &#39;)
        def func_input___CHAR_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : dig COMMA func_input &#39;)
        def func_input___dig_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : VAR_NAME COMMA func_input &#39;)
        def func_input___VAR_NAME_COMMA_func_input_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : STRING  &#39;)
        def func_input___STRING__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : CHAR  &#39;)
        def func_input___CHAR__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : dig  &#39;)
        def func_input___dig__(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;func_input : VAR_NAME &#39;)
        def func_input___VAR_NAME_(p):
            newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : LESS_THAN &#39;)
        def comp___LESS_THAN_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : GREATER_THAN &#39;)
        def comp___GREATER_THAN_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : EQUAL_TO &#39;)
        def comp___EQUAL_TO_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : LEQ &#39;)
        def comp___LEQ_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : GEQ &#39;)
        def comp___GEQ_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;comp : NOT_EQUAL_TO &#39;)
        def comp___NOT_EQUAL_TO_(p):
            newNode = ParseTree(&#34;COMP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : PLUS &#39;)
        def op___PLUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : MINUS &#39;)
        def op___MINUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : DIVIDE &#39;)
        def op___DIVIDE_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : TIMES &#39;)
        def op___TIMES_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : MODULUS &#39;)
        def op___MODULUS_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : BW_AND &#39;)
        def op___BW_AND_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : BW_OR &#39;)
        def op___BW_OR_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : NEGATE &#39;)
        def op___NEGATE_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : LEFT_SHIFT &#39;)
        def op___LEFT_SHIFT_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : RIGHT_SHIFT &#39;)
        def op___RIGHT_SHIFT_(p):
            newNode = ParseTree(&#34;OP&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;op : XOR &#39;)
        def op___XOR_(p):
            newNode = ParseTree(&#34;&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;dig : INT &#39;)
        def dig___INT_(p):
            newNode = ParseTree(&#34;DIG&#34;,p)
            self.Head = newNode
            return newNode

        @self.pg.production(&#39;dig : FLOAT &#39;)
        def dig___FLOAT_(p):
            newNode = ParseTree(&#34;DIG&#34;,p)
            self.Head = newNode
            return newNode


        @self.pg.error
        def error_handle(token):
            &#34;&#34;&#34;
            Boilerplate error handling function

            Args:
                token: The token that caused an error.
            &#34;&#34;&#34;
            return ValueError(token)

    #boilerplate function
    def get_parser(self):
        &#34;&#34;&#34;
        Retrieves the built version of the parser.

        Returns:
            The built parser.
        &#34;&#34;&#34;
        return self.pg.build()

    #retrieve the trees head
    def getTree(self):
        &#34;&#34;&#34;
        Getter for the head of the tree.

        Returns:
            The head of the tree.
        &#34;&#34;&#34;

        return self.Head

    def print_error(self):
        &#34;&#34;&#34;
        Prints parser error message. This function ultimately iterates through the ParseTree that was returned after the parser found an error. ParseTree&#39;s consist of tokens as well as other ParseTree&#39;s so we need to iterate to find the first token and then print its source position.
        &#34;&#34;&#34;
        # TODO: add some more in-depth error processing to print
        # out a more detailed description of what went wrong, and possibly some suggestions
        # at to why there was a parse/syntax error. (i.e. suggest a missing semicolon)

        head = self.getTree()
        token = 0 # token hasn&#39;t been found yet, so we set value to 0

        while True and head:
            # Iterate through list of elements
            for i in head.content:

                # Could be a Token
                if(type(i) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):

                    # Found a Token
                    token = i
                    break

            # Check again (to break out of while loop and not iterate again)
            if (type(token) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):
                break
            else:
                # Set head to last element.
                # If this code executes then I can assume that the
                # last element is an ParseTree.
                head = head.content[len(head.content)-1]

        if token:
            print(f&#34;ParsingError: Last token  \&#39;{token.value}\&#39; parsed successfully at, {token.source_pos}\n&#34;)
        else:
            # Never found a token to report, need to exit
            print(&#34;ParsingError: No ParseTree obtained\n&#34;)
            exit()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.import_ir.Parser.getTree"><code class="name flex">
<span>def <span class="ident">getTree</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Getter for the head of the tree.</p>
<h2 id="returns">Returns</h2>
<p>The head of the tree.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTree(self):
    &#34;&#34;&#34;
    Getter for the head of the tree.

    Returns:
        The head of the tree.
    &#34;&#34;&#34;

    return self.Head</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.Parser.get_parser"><code class="name flex">
<span>def <span class="ident">get_parser</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the built version of the parser.</p>
<h2 id="returns">Returns</h2>
<p>The built parser.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parser(self):
    &#34;&#34;&#34;
    Retrieves the built version of the parser.

    Returns:
        The built parser.
    &#34;&#34;&#34;
    return self.pg.build()</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The list of BNF functions and their behavior for the gimple IR.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self):
    &#34;&#34;&#34;
    The list of BNF functions and their behavior for the gimple IR.
    &#34;&#34;&#34;

    @self.pg.production(&#39;program : function_def &#39;)
    def program___function_def_(p):
        newNode = ParseTree(&#34;PROGRAM&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;program : function_def program &#39;)
    def program___function_def_program_(p):
        newNode = ParseTree(&#34;PROGRAM&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;program :  &#39;)
    def program____(p):
        newNode = ParseTree(&#34;PROGRAM&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;function_def : VAR_NAME OPEN_PAREN parameters CLOSE_PAREN OPEN_BRACK content CLOSE_BRACK &#39;)
    def function_def___VAR_NAME_OPEN_PAREN_parameters_CLOSE_PAREN_OPEN_BRACK_content_CLOSE_BRACK_(p):

        newNode = ParseTree(&#34;FUNCTION_DEF&#34;,p)
        self.Head = newNode
        #first, convert parameters to a string form
        #also, get the string representation of VAR_NAME

        tokens = []
        tokens += [x.value for x in p[2].content if isinstance(x,Token)]
        tokenSets = [x for x in p[2].content if isinstance(x,ParseTree)]
        while tokenSets != []:
            for i in tokenSets:
                tokens += [x.value for x in i.content if isinstance(x,Token)]
                tokenSets = [x for x in i.content if isinstance(x,ParseTree)]


        functioName = p[0].value
        params = &#34; &#34;.join(tokens)
        IRNodeToReturn = irl.IRFunctionDecl(functioName,params)
        self.ls.append(IRNodeToReturn)
        return newNode

    @self.pg.production(&#39;parameters : TYPE VAR_NAME COMMA parameters &#39;)
    def parameters___TYPE_VAR_NAME_COMMA_parameters_(p):
        newNode = ParseTree(&#34;PARAMATERS&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;parameters : TYPE VAR_NAME &#39;)
    def parameters___TYPE_VAR_NAME_(p):
        newNode = ParseTree(&#34;PARAMETERS&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;parameters : &#39;)
    def parameters___(p):
        newNode = ParseTree(&#34;PARAMETERS&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;content : line &#39;)
    def content___line_(p):
        newNode = ParseTree(&#34;CONTENT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;content : content content &#39;)
    def content___content_content_(p):
        newNode = ParseTree(&#34;CONTENT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;content : &#39;)
    def content___(p):
        newNode = ParseTree(&#34;CONTENT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;content : OPEN_BRACK content CLOSE_BRACK &#39;)
    def content___OPEN_BRACK_content_CLOSE_BRACK_(p):
        newNode = ParseTree(&#34;CONTENT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;line : TYPE D_NUM SEMICOLON &#39;)
    def line___TYPE_D_NUM_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        typ = p[0]
        name = p[1]
        IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
        self.ls.append(IRNodeToReturn)

        return newNode

    @self.pg.production(&#39;line : TYPE VAR_NAME SEMICOLON &#39;)
    def line___TYPE_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        #needs modifiers, type, and varname
        #modifiers is none
        typ = p[0]
        name = p[1]
        IRNodeToReturn = irl.IRVariableInit(&#34;&#34;,typ.value, name.value)
        self.ls.append(IRNodeToReturn)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS dig op dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_dig_op_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = p[2].content[0].value
        rhs = p[4].content[0].value
        op = p[3].content[0].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].content[0].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS STRING SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_STRING_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS CHAR SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_CHAR_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_VAR_NAME_op_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = p[2].value
        rhs = p[4].content[0].value
        op = p[3].content[0].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS dig op VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_dig_op_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = p[2].content[0].value
        rhs = p[4].value
        op = p[3].content[0].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS VAR_NAME op VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_VAR_NAME_op_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = p[2].value
        rhs = p[4].value
        op = p[3].content[0].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_MINUS_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = 0
        rhs = p[3].content[0].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS MINUS VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_MINUS_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode

        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = 0
        rhs = p[3].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_PLUS_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode

        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = 0
        rhs = p[3].content[0].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS PLUS VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_PLUS_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = 0
        rhs = p[3].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_NEGATE_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = &#34;&#34;
        rhs = p[3].content[0].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS NOT dig SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_NOT_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode

        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = &#34;&#34;
        rhs = p[3].content[0].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS NOT VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_NOT_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode

        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = &#34;&#34;
        rhs = p[3].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS NEGATE VAR_NAME SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_NEGATE_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        IRNodeToBeReturned = irl.IRArth(None,None,None)
        varName = p[0].value
        lhs = &#34;&#34;
        rhs = p[3].value
        op = p[2].value

        IRNodeToBeReturned.fileInit(lhs,op,rhs,varName)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS NULL SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_NULL_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : D_NUM EQUALS VAR_NAME SEMICOLON &#39;)
    def line___D_NUM_EQUALS_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : D_NUM EQUALS dig SEMICOLON &#39;)
    def line___D_NUM_EQUALS_dig_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].content[0].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : D_NUM EQUALS STRING SEMICOLON &#39;)
    def line___D_NUM_EQUALS_STRING_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : D_NUM EQUALS CHAR SEMICOLON &#39;)
    def line___D_NUM_EQUALS_CHAR_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[0].value
        rhs = p[2].value
        NodeToBeReturned = irl.IRAssignment(lhs,rhs)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : RETURN D_NUM SEMICOLON &#39;)
    def line___RETURN_D_NUM_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        #just needs value, should be p[1]
        value = p[1].value
        NodeToBeReturned = irl.IRReturn(value)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : func_call SEMICOLON &#39;)
    def line___func_call_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        func_name = p[0].content[0].value
        contentList = p[0].content[2]
        params = []
        while contentList != []:
            # print(&#34;SJSD&#34;)
            params.append(contentList.content[0].value)
            if(len(contentList.content) == 3):
                contentList = contentList.content[2]
            else:
                contentList =[]
        #NEED TO IDENTIF WHAT IR NODE THIS BECOMES, WE HAVE THE PARAMS AND THE NAME
        return newNode

    @self.pg.production(&#39;line : VAR_NAME EQUALS func_call SEMICOLON &#39;)
    def line___VAR_NAME_EQUALS_func_call_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        func_name = p[2].content[0].value
        contentList = p[2].content[2]
        params = []
        lhs = p[0].value
        while contentList != []:
            params.append(contentList.content[0].value)
            if(len(contentList.content) == 3):
                contentList = contentList.content[2]
            else:
                contentList =[]
        IRNodeToBeReturned = irl.IRFunctionAssign(None,None,None)
        IRNodeToBeReturned.LineFromFile(lhs,func_name,params)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : IF OPEN_PAREN condition CLOSE_PAREN GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON ELSE GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
    def line___IF_OPEN_PAREN_condition_CLOSE_PAREN_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_ELSE_GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        lhs = p[2].content[0].value
        rhs = p[2].content[2].value
        compOp = p[2].content[1].content[0].value
        succ = p[6].value.split(&#34;.&#34;)[1]
        fail = p[12].value.split(&#34;.&#34;)[1]
        IRNodeToBeReturned = irl.IRIf(None,None,None,None)
        IRNodeToBeReturned.fileInit(lhs,rhs,compOp,succ,fail)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : LESS_THAN D_NUM GREATER_THAN COLON &#39;)
    def line___LESS_THAN_D_NUM_GREATER_THAN_COLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        #name of the label
        nameLabel = p[1].value
        IRNodeToBeReturned = irl.IRJump(nameLabel)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : GOTO LESS_THAN D_NUM GREATER_THAN SEMICOLON &#39;)
    def line___GOTO_LESS_THAN_D_NUM_GREATER_THAN_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        name = &#34;&#34;.join([p[1].value, p[2].value, p[3].value])
        IRNodeToBeReturned = irl.IRGoTo(name)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : GOTO VAR_NAME SEMICOLON &#39;)
    def line___GOTO_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        name = p[1].value
        IRNodeToBeReturned = irl.IRGoTo(name)
        self.ls.append(IRNodeToBeReturned)
        return newNode

    @self.pg.production(&#39;line : VAR_NAME COLON &#39;)
    def line___VAR_NAME_COLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        nameLabel = p[0].value
        IRNodeToBeReturned = irl.IRJump(nameLabel)
        self.ls.append(IRNodeToBeReturned)

        return newNode

    @self.pg.production(&#39;line : KEWORD TYPE VAR_NAME SEMICOLON &#39;)
    def line___KEWORD_TYPE_VAR_NAME_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;line : RETURN SEMICOLON &#39;)
    def line___RETURN_SEMICOLON_(p):
        newNode = ParseTree(&#34;LINE&#34;,p)
        self.Head = newNode
        value = &#34;&#34;
        NodeToBeReturned = irl.IRReturn(value)
        self.ls.append(NodeToBeReturned)
        return newNode

    @self.pg.production(&#39;condition : VAR_NAME comp VAR_NAME &#39;)
    def condition___VAR_NAME_comp_VAR_NAME_(p):
        newNode = ParseTree(&#34;CONDITION&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;condition : VAR_NAME comp dig &#39;)
    def condition___VAR_NAME_comp_dig_(p):
        newNode = ParseTree(&#34;CONDITION&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;condition : dig comp dig &#39;)
    def condition___dig_comp_dig_(p):
        newNode = ParseTree(&#34;CONDITION&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;condition : dig comp VAR_NAME &#39;)
    def condition___dig_comp_VAR_NAME_(p):
        newNode = ParseTree(&#34;CONDITION&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_call : VAR_NAME OPEN_PAREN func_input CLOSE_PAREN &#39;)
    def func_call___VAR_NAME_OPEN_PAREN_func_input_CLOSE_PAREN_(p):
        newNode = ParseTree(&#34;FUNC_CALL&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : &#39;)
    def func_input___(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : STRING COMMA func_input &#39;)
    def func_input___STRING_COMMA_func_input_(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : CHAR COMMA func_input &#39;)
    def func_input___CHAR_COMMA_func_input_(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : dig COMMA func_input &#39;)
    def func_input___dig_COMMA_func_input_(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : VAR_NAME COMMA func_input &#39;)
    def func_input___VAR_NAME_COMMA_func_input_(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : STRING  &#39;)
    def func_input___STRING__(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : CHAR  &#39;)
    def func_input___CHAR__(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : dig  &#39;)
    def func_input___dig__(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;func_input : VAR_NAME &#39;)
    def func_input___VAR_NAME_(p):
        newNode = ParseTree(&#34;FUNC_INPUT&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : LESS_THAN &#39;)
    def comp___LESS_THAN_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : GREATER_THAN &#39;)
    def comp___GREATER_THAN_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : EQUAL_TO &#39;)
    def comp___EQUAL_TO_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : LEQ &#39;)
    def comp___LEQ_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : GEQ &#39;)
    def comp___GEQ_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;comp : NOT_EQUAL_TO &#39;)
    def comp___NOT_EQUAL_TO_(p):
        newNode = ParseTree(&#34;COMP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : PLUS &#39;)
    def op___PLUS_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : MINUS &#39;)
    def op___MINUS_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : DIVIDE &#39;)
    def op___DIVIDE_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : TIMES &#39;)
    def op___TIMES_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : MODULUS &#39;)
    def op___MODULUS_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : BW_AND &#39;)
    def op___BW_AND_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : BW_OR &#39;)
    def op___BW_OR_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : NEGATE &#39;)
    def op___NEGATE_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : LEFT_SHIFT &#39;)
    def op___LEFT_SHIFT_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : RIGHT_SHIFT &#39;)
    def op___RIGHT_SHIFT_(p):
        newNode = ParseTree(&#34;OP&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;op : XOR &#39;)
    def op___XOR_(p):
        newNode = ParseTree(&#34;&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;dig : INT &#39;)
    def dig___INT_(p):
        newNode = ParseTree(&#34;DIG&#34;,p)
        self.Head = newNode
        return newNode

    @self.pg.production(&#39;dig : FLOAT &#39;)
    def dig___FLOAT_(p):
        newNode = ParseTree(&#34;DIG&#34;,p)
        self.Head = newNode
        return newNode


    @self.pg.error
    def error_handle(token):
        &#34;&#34;&#34;
        Boilerplate error handling function

        Args:
            token: The token that caused an error.
        &#34;&#34;&#34;
        return ValueError(token)</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.Parser.print_error"><code class="name flex">
<span>def <span class="ident">print_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints parser error message. This function ultimately iterates through the ParseTree that was returned after the parser found an error. ParseTree's consist of tokens as well as other ParseTree's so we need to iterate to find the first token and then print its source position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_error(self):
    &#34;&#34;&#34;
    Prints parser error message. This function ultimately iterates through the ParseTree that was returned after the parser found an error. ParseTree&#39;s consist of tokens as well as other ParseTree&#39;s so we need to iterate to find the first token and then print its source position.
    &#34;&#34;&#34;
    # TODO: add some more in-depth error processing to print
    # out a more detailed description of what went wrong, and possibly some suggestions
    # at to why there was a parse/syntax error. (i.e. suggest a missing semicolon)

    head = self.getTree()
    token = 0 # token hasn&#39;t been found yet, so we set value to 0

    while True and head:
        # Iterate through list of elements
        for i in head.content:

            # Could be a Token
            if(type(i) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):

                # Found a Token
                token = i
                break

        # Check again (to break out of while loop and not iterate again)
        if (type(token) == type(Token(&#34;sample&#34;, &#34;sample&#34;))):
            break
        else:
            # Set head to last element.
            # If this code executes then I can assume that the
            # last element is an ParseTree.
            head = head.content[len(head.content)-1]

    if token:
        print(f&#34;ParsingError: Last token  \&#39;{token.value}\&#39; parsed successfully at, {token.source_pos}\n&#34;)
    else:
        # Never found a token to report, need to exit
        print(&#34;ParsingError: No ParseTree obtained\n&#34;)
        exit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.import_ir.import_ir"><code class="flex name class">
<span>class <span class="ident">import_ir</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>This function initializes the object that imports the IR, it takes in the filename of the file being imported.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>The filename of the IR</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class import_ir():
    def __init__(self, filename):
        &#34;&#34;&#34;
        This function initializes the object that imports the IR, it takes in the filename of the file being imported.

        Args:
            filename: The filename of the IR

        &#34;&#34;&#34;
        self.IR = []
        with open(filename,&#34;r&#34;) as fd:
            self.data = fd.read()
            self.tokens = None

    def tokenize(self):
        &#34;&#34;&#34;
        This will tokenize the IR that has been read in.

        &#34;&#34;&#34;

        text_input = self.data.strip()
        lexer = IR_Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        self.tokens = tokens

    def parse(self):
        &#34;&#34;&#34;
        This function parses the IR after it has been tokenized, and returns the list of lines in the IR as IRNodes

        Returns:
            A list of the IRNodes that make up this IR file
        &#34;&#34;&#34;

        pg = Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(self.tokens)

        head = pg.getTree()
        # here, sort the list of IRNodes that have been generated by the parser,
        # since the bottom up nature of the parse means it will parse function_definitions after lines
        finalLs = []
        tempLs = []
        for i in pg.ls:
            if(isinstance(i,irl.IRFunctionDecl)):
                tempLs.insert(0,i)
                tempLs.insert(1,irl.IRBracket(True))
                finalLs += tempLs
                finalLs.append(irl.IRBracket(False))
                tempLs = []
            else:
                tempLs.append(i)
        for i in finalLs:
            toAdd = irl.IRLine(None)
            toAdd.treeList = [i]
            self.IR.append(toAdd)
        return finalLs

    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in finalLs])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.import_ir.import_ir.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function parses the IR after it has been tokenized, and returns the list of lines in the IR as IRNodes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>list</code> of <code>the</code> <code>IRNodes</code> <code>that</code> <code>make</code> <code>up</code> <code>this</code> <code>IR</code> <code>file</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self):
    &#34;&#34;&#34;
    This function parses the IR after it has been tokenized, and returns the list of lines in the IR as IRNodes

    Returns:
        A list of the IRNodes that make up this IR file
    &#34;&#34;&#34;

    pg = Parser()
    pg.parse()
    parser = pg.get_parser()
    parser.parse(self.tokens)

    head = pg.getTree()
    # here, sort the list of IRNodes that have been generated by the parser,
    # since the bottom up nature of the parse means it will parse function_definitions after lines
    finalLs = []
    tempLs = []
    for i in pg.ls:
        if(isinstance(i,irl.IRFunctionDecl)):
            tempLs.insert(0,i)
            tempLs.insert(1,irl.IRBracket(True))
            finalLs += tempLs
            finalLs.append(irl.IRBracket(False))
            tempLs = []
        else:
            tempLs.append(i)
    for i in finalLs:
        toAdd = irl.IRLine(None)
        toAdd.treeList = [i]
        self.IR.append(toAdd)
    return finalLs</code></pre>
</details>
</dd>
<dt id="src.optimizer.import_ir.import_ir.tokenize"><code class="name flex">
<span>def <span class="ident">tokenize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This will tokenize the IR that has been read in.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokenize(self):
    &#34;&#34;&#34;
    This will tokenize the IR that has been read in.

    &#34;&#34;&#34;

    text_input = self.data.strip()
    lexer = IR_Lexer().get_lexer()
    tokens = lexer.lex(text_input)
    self.tokens = tokens</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.optimizer" href="index.html">src.optimizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.optimizer.import_ir.print_error" href="#src.optimizer.import_ir.print_error">print_error</a></code></li>
<li><code><a title="src.optimizer.import_ir.tokensToString" href="#src.optimizer.import_ir.tokensToString">tokensToString</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.optimizer.import_ir.IR_Lexer" href="#src.optimizer.import_ir.IR_Lexer">IR_Lexer</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.import_ir.IR_Lexer.get_lexer" href="#src.optimizer.import_ir.IR_Lexer.get_lexer">get_lexer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.import_ir.ParseTree" href="#src.optimizer.import_ir.ParseTree">ParseTree</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.import_ir.ParseTree.getListView" href="#src.optimizer.import_ir.ParseTree.getListView">getListView</a></code></li>
<li><code><a title="src.optimizer.import_ir.ParseTree.print_ParseTree" href="#src.optimizer.import_ir.ParseTree.print_ParseTree">print_ParseTree</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.import_ir.Parser" href="#src.optimizer.import_ir.Parser">Parser</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.import_ir.Parser.getTree" href="#src.optimizer.import_ir.Parser.getTree">getTree</a></code></li>
<li><code><a title="src.optimizer.import_ir.Parser.get_parser" href="#src.optimizer.import_ir.Parser.get_parser">get_parser</a></code></li>
<li><code><a title="src.optimizer.import_ir.Parser.parse" href="#src.optimizer.import_ir.Parser.parse">parse</a></code></li>
<li><code><a title="src.optimizer.import_ir.Parser.print_error" href="#src.optimizer.import_ir.Parser.print_error">print_error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.import_ir.import_ir" href="#src.optimizer.import_ir.import_ir">import_ir</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.import_ir.import_ir.parse" href="#src.optimizer.import_ir.import_ir.parse">parse</a></code></li>
<li><code><a title="src.optimizer.import_ir.import_ir.tokenize" href="#src.optimizer.import_ir.import_ir.tokenize">tokenize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>