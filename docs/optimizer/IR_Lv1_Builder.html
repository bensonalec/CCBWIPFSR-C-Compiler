<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.optimizer.IR_Lv1_Builder API documentation</title>
<meta name="description" content="This module serves to construct the first linear intermediate representation in the compiler." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.optimizer.IR_Lv1_Builder</code></h1>
</header>
<section id="section-intro">
<p>This module serves to construct the first linear intermediate representation in the compiler.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module serves to construct the first linear intermediate representation in the compiler.
&#34;&#34;&#34;
import os
import re
import sys
import math

from inspect import getsourcefile
from importlib.machinery import SourceFileLoader
from copy import deepcopy, copy

irl = SourceFileLoader(&#34;IRLine&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/IRLine.py&#34;).load_module()
ast = SourceFileLoader(&#34;AST_builder&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/../frontend/AST_builder.py&#34;).load_module()

class LevelOneIR():
    &#34;&#34;&#34;
    Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.
    &#34;&#34;&#34;
    def __init__(self,astHead,symTable):
        &#34;&#34;&#34;
        Args:
            astHead: The root node of the AST
            symTable: The symbol table for the input
        &#34;&#34;&#34;
        self.astHead = astHead
        self.symTable = symTable
        self.IR = []

    def construct(self):
        &#34;&#34;&#34;
        Constructs the linear representation for the object.

        Returns:
            IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
        &#34;&#34;&#34;
        sym = self.symTable
        ntv = self.astHead

        varIndex = 0
        lastVarName = &#34;_&#34; + str(varIndex)
        bodyList = []

        # list of all bodies within functions in our C program
        for x in self.astHead.children:
            if x.name == &#34;func&#34;:
                # Each entry is the &#39;(func_node, body_node)&#39;
                bodyList.append((x,x.children[3]))

        returnDigit = 1234
        labelDigit = returnDigit + 1
        lines = []

        for i in bodyList:
            # Beginning of fuction wrapper
            lines.extend(beginWrapper(i, returnDigit))

            # Body of function
            tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
            lines.extend(tmp_lines)

            # End of function wrapper, add closing bracket
            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

            # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
            returnDigit = labelDigit

            self.IR = lines

        return self.IR


    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in self.IR]) + &#34;\n&#34;

    def optimize(self, opt):
        if opt &gt; 0:
            self.remove_unused_funcs()
            self.remove_unused_vars()
            pass

        if opt &gt; 1:
            # A dictionary containing all the values of variables that can at some point be reduced.
            self.var_values = {
                func.name : {
                    var.name : &#34;Undef&#34;
                    for var in self.symTable.symbols if var.entry_type == 0 and var.scope.startswith(f&#34;/{func.name}&#34;)
                }
                for func in [sym for sym in self.symTable.symbols if sym.entry_type == 1]
            }

            # NOTE: As a method of knowing whether it is safe to continue on to the next node in the list the following measures have been implemented:
            # Both constant folding and constant propagation only consider a singular value.
            # They both return a boolean describing whether the node was altered as well as some descriptor of what it did.
                # In the case of constant folding, the descriptor is the new simplified node which then has to be assigned to the correct index.
                # In the case of constant propagation, the descriptor is a dictionary containing the updated values relevant to the scope of the IRLine object meaning that tempoary variables are stored within the IRLine but now within the scope as a whole.
            # The idea is that while either of these methods can alter the node you keep executing them on the node so that if the loop terminates the program is sure that the node cannot be reduced further.
            # Another final optimization that can be done would be to check if all the nodes in an IRLine object are `IRAssignment`, if so the last one is the only `IRAssignment` node needed, and the others can be removed.

            prev_maj = 0
            cur_scope = &#34;&#34;
            tmp_vals = {}
            for major, minor, node in [(major, minor, node) for major, tl in enumerate(self.IR) for minor, node in enumerate(tl.treeList)]:
                if major != prev_maj:
                    tmp_vals = {}

                if isinstance(node, irl.IRFunctionDecl):
                    cur_scope = node.name
                elif isinstance(node, irl.IRGoTo) or isinstance(node, irl.IRJump) or isinstance(node, irl.IRIf):
                    for val in tmp_vals.items():
                        if val[0] in self.var_values[cur_scope]:
                            self.var_values[cur_scope][val[0]] = &#34;Undef&#34;
                        tmp_vals[val[0]] = &#34;Undef&#34;
                else:
                    for val in self.var_values[cur_scope].items():
                        tmp_vals[val[0]] = val[1]

                ncf = False
                ncp = False

                while 1:
                    ncf, tmp = self.constant_folding(node)

                    if ncf:
                        self.IR[major].treeList[minor] = tmp
                        node = tmp

                    ncp, vals = self.constant_propagation(node, tmp_vals)

                    for val in vals.items():
                        if val[0] in self.var_values[cur_scope]:
                            self.var_values[cur_scope][val[0]] = val[1]
                        tmp_vals[val[0]] = val[1]

                    if not (ncf or ncp):
                        break
                prev_maj = major

            self.cleanup()

    def remove_unused_vars(self):
        ir = self.IR
        scope = &#34;&#34;

        #get variables to remove
        vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
        #get function from symbol table.
        funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

        final_ir = []

        for irLine in ir:

            for idx, irNode in enumerate(irLine.treeList):
                #check if function declaration, to set new scope
                if isinstance(irNode, irl.IRFunctionDecl):
                    scope = irNode.name

                #check if declaration
                if isinstance(irNode, irl.IRVariableInit):
                    #check if variable needs to be skippped
                    if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                        del irLine.treeList[idx]

                #check if usage
                elif(isinstance(irNode, irl.IRAssignment)):
                    if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                        del irLine.treeList[idx]

            #irLine has no irNode inside...so we dont add it to new IR list
            if irLine.treeList == []:
                pass
            else:
                final_ir.append(irLine)


        self.IR = final_ir

    def cleanup(self):

        class ref():
            def __init__(self, init_index, init_ref_type, side):
                self.refs = [init_index]
                self.ref_types = [init_ref_type]
                self.side = [side]

            def add(self, index, ref_type, side):
                self.refs.append(index)
                self.ref_types.append(ref_type)
                self.side.append(side)

            def __str__(self):
                return f&#34;\t{self.refs}\t{self.ref_types}\t{self.side}&#34;

            def __repr__(self):
                return self.__str__()

        gr = {}
        for line in self.IR:
            lr = {}

            for i, node in enumerate(line.treeList):
                if isinstance(node, irl.IRAssignment):
                    if node.lhs in lr:
                        lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                    tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.rhs in lr and not tmp.isnumeric():
                        lr[node.rhs].add(i, &#34;assignment&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.rhs] = ref(i, &#34;assignment&#34;, 1)
                elif isinstance(node, irl.IRArth):
                    if node.var in lr:
                        lr[node.var].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.var] = ref(i, &#34;assignment&#34;, 0)

                    tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.lhs in lr and not tmp.isnumeric():
                        lr[node.lhs].add(i, &#34;arithmetic&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.lhs] = ref(i, &#34;arithmetic&#34;, 1)

                    if node.rhs:
                        tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if node.rhs in lr and not tmp.isnumeric():
                            lr[node.rhs].add(i, &#34;arithmetic&#34;, 2)
                        elif not tmp.isnumeric():
                            lr[node.rhs] = ref(i, &#34;arithmetic&#34;, 2)
                elif isinstance(node, irl.IRFunctionAssign):
                    if node.lhs in lr:
                        lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                    for param in node.params:
                        tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if param in lr and not tmp.isnumeric():
                            lr[node.lhs].add(i, &#34;param&#34;, 1)
                        elif not tmp.isnumeric():
                            lr[node.lhs] = ref(i, &#34;param&#34;, 1)
                elif isinstance(node, irl.IRIf):
                    tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.lhs in lr and not tmp.isnumeric():
                        lr[node.lhs].add(i, &#34;collation&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.lhs] = ref(i, &#34;collation&#34;, 1)

                    tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.rhs in lr and not tmp.isnumeric():
                        lr[node.rhs].add(i, &#34;collation&#34;, 2)
                    elif not tmp.isnumeric():
                        lr[node.rhs] = ref(i, &#34;collation&#34;, 2)
                elif isinstance(node, irl.IRSpecial):
                    if node.var in lr:
                        lr[node.var].add(i, &#34;assignment&#34;, 0)
                        lr[node.var].add(i, &#34;assignment&#34;, 1)
                    else:
                        lr[node.var] = ref(i, &#34;assignment&#34;, 0)
                        lr[node.var].add(i, &#34;assignment&#34;, 1)
                elif isinstance(node, irl.IRReturn):
                    if node.value:
                        tmp = node.value.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if node.value in lr:
                            lr[node.value].add(i, &#34;return&#34;, 0)
                        elif not tmp.isnumeric():
                            lr[node.value] = ref(i, &#34;return&#34;, 0)
            rem_list = []

            for var in lr.items():
                # print(var)
                for i, typ in enumerate(var[1].ref_types):
                    if (
                        i+1 &lt; len(var[1].ref_types)
                        and
                        typ == &#34;assignment&#34;
                        and
                        var[1].side[i] == 0
                        and
                        var[1].side[i+1] == 0
                        and
                        var[1].ref_types[i+1] == &#34;assignment&#34;
                        ):
                        rem_list.append(var[1].refs[i])
                    elif (
                        i+1 == len(var[1].ref_types)
                        and
                        typ == &#34;assignment&#34;
                        and
                        var[1].side[i] == 0
                        # and
                        # var[1].side[i+1] == 0
                        and
                        (
                            var[1].refs[i]+1 != len(line.treeList)
                            or
                            len(var[1].ref_types) &gt; 1)
                        ):
                        rem_list.append(var[1].refs[i])

                # iterate over reference types and see if there are two assignments after each other.


            for node in reversed(sorted(rem_list)):
                line.treeList.pop(node)

    def remove_unused_funcs(self):
        ir = self.IR
        inFunction = False
        to_remove = []

        for idx, irLine in enumerate(ir):

            # Only need to focus on first Node in each IRLine
            ir_firstNode = irLine.treeList[0]

            # Delete IRLine if we are in a &#39;unused&#39; function
            # Mark &#39;inFunction&#39; to False if beginning of new function
            if inFunction == True:
                if isinstance(ir_firstNode, irl.IRFunctionDecl):
                    inFunction = False
                else:
                    to_remove.append(idx)
                    continue

            # Check for function
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                func_name = ir_firstNode.name
                referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])

                # If reference is 0, it is unused
                if referenceNum == 0 and func_name != &#34;main&#34;:
                    to_remove.append(idx)
                    inFunction = True

        # Actually delete unused function IRLine&#39;s
        for i in to_remove[::-1]:
            del ir[i]


        self.IR = ir

    def constant_folding(self,x):
        changed = False
        if isinstance(x,irl.IRArth):
            notFound = True
            op = False
            #get the operator being used
            if(x.rhs != None and x.lhs != None):
                if(x.operator == &#34;+&#34;):
                    op = lambda lhs, rhs : lhs + rhs
                elif(x.operator == &#34;-&#34;):
                    op = lambda lhs, rhs : lhs - rhs
                elif(x.operator == &#34;*&#34;):
                    op = lambda lhs, rhs : lhs * rhs
                elif(x.operator == &#34;/&#34;):
                    op = lambda lhs, rhs : lhs / rhs
                elif(x.operator == &#34;%&#34;):
                    op = lambda lhs, rhs : math.fmod(lhs, rhs)
                elif(x.operator == &#34;&lt;&lt;&#34;):
                    # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &lt;&lt; 31 compared to 10 &lt;&lt; 20
                    op = lambda lhs, rhs : lhs &lt;&lt; rhs
                elif(x.operator == &#34;&gt;&gt;&#34;):
                    # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &gt;&gt; 31 compared to 10 &gt;&gt; 20
                    op = lambda lhs, rhs : lhs &gt;&gt; rhs
                elif(x.operator == &#34;|&#34;):
                    op = lambda lhs, rhs : lhs | rhs
                elif(x.operator == &#34;&amp;&#34;):
                    op = lambda lhs, rhs : lhs &amp; rhs
                elif(x.operator == &#34;^&#34;):
                    op = lambda lhs, rhs : lhs ^ rhs
            else:
                if(x.operator == &#34;~&#34;):
                    op = lambda lhs, rhs : ~lhs
                elif(x.operator == &#34;-&#34;):
                    op = lambda lhs, rhs : 0 - lhs
                elif(x.operator == &#34;+&#34;):
                    op = lambda lhs, rhs : 0 + lhs
                elif(x.operator == &#34;!&#34;):
                    op = lambda lhs, rhs : not lhs
            #get the left hand side and the right hand side
            try:
                lhs = int(x.lhs)
                if(not x.rhs == None):
                    rhs = int(x.rhs)
                else:
                    rhs = None
                notFound = False
            except ValueError:
                try:
                    lhs = float(x.lhs)
                    if(not x.rhs == None):
                        rhs = float(x.rhs)
                    else:
                        rhs = None
                    notFound = False
                except ValueError:
                    pass

            #if we found all components, replace the node
            if(not notFound and op):
                if rhs and rhs &lt; 0:
                    if x.operator == &#34;&lt;&lt;&#34; or x.operator == &#34;&gt;&gt;&#34;:
                        raise ValueError(&#34;shifting by negative number is undefined behavior.&#34;)

                newValue = lambda lhs, rhs, op : op(lhs,rhs)
                val = newValue(lhs,rhs,op) if isinstance(lhs, float) or isinstance(rhs, float) else math.floor(newValue(lhs,rhs,op))
                newAss = irl.IRAssignment(x.var, str(val))
                changed = True
                return changed,newAss
        return changed,x

    def constant_propagation(self, node, var_val):

        # NOTE: The current issue is that the propogation is goint to have to exit and re enter the function every time to achieve the following:
        # Clear the tempoary variables per line as they are re used
        # Avoid propogating too far so that assignments in the future that may happen after certain other computations and assignments propogate the correct value

        # TODO: Fix to detect whether the reference is necessary or not. Eg, comparisons in loops compared to simple ifs
        # TODO: Ensure that when comming across a value that is not computable or propogatable such as after some control flow, the dictionary value becomes something distinguisable so that the expression is left alone
        changed = False
        if isinstance(node, irl.IRIf):
            if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
                node.lhs = var_val[node.lhs]
                changed = True
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                changed = True

        elif isinstance(node, irl.IRArth):
            if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
                node.lhs = var_val[node.lhs]
                changed = True
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                changed = True

        elif isinstance(node, irl.IRSpecial):
            pass
            # Assigning a value for a post and pre increment is extremly difficult due to the fact that it regularly occurs in loops and constants arent useful there.

        elif isinstance(node, irl.IRAssignment):
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                var_val[node.lhs] = node.rhs
                changed = True
            else:
                tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if tmp.isnumeric():
                    var_val[node.lhs] = node.rhs

        elif isinstance(node, irl.IRFunctionAssign):
            for j, param in enumerate(node.params):
                if param in var_val and var_val[param] != None:
                    node.params[j] = var_val[param]
                    changed = True

        return changed, var_val

def buildBoilerPlate(symTable):
    namesandparams = []
    functionNames = [(x.name,x.type) for x in symTable.symbols if x.is_function]
    params = [(x.name,x.scope,x.type) for x in symTable.symbols if x.is_param]

    for x in functionNames:
        track = 0
        paramsLi = []
        for i in params:
            if x[0] == i[1].split(&#34;/&#34;)[1]:
                track+=1

                paramsLi.append((i[2],i[0]))
        if track == 0:
            namesandparams.append((x[0],paramsLi,x[1]))
        else:
            namesandparams.append((x[0],paramsLi,x[1]))
    return namesandparams

def beginWrapper(function_tuple, returnDigit):
    &#34;&#34;&#34;
    Produces the function wrappers and initializes the return digit for the given function.

    Returns:
        lines: The lines of the start of the function
    &#34;&#34;&#34;
    lines = []
    params = &#34;&#34;
    func_type = function_tuple[0].children[0].name
    func_name = function_tuple[0].children[1].name

    for var in function_tuple[0].children[2].children:
        if var.name == &#34;var&#34;:
            params += f&#34;{var.children[0].name} {var.children[1].name},&#34;

    lines.append(irl.IRLine.singleEntry(irl.IRFunctionDecl(func_name, params[:-1])))
    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True)))

    if func_type != &#34;void&#34;:
        modifiers = f&#34;{&#39;&#39;.join([x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]])}{&#39; &#39; if [x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]] else &#39;&#39;}&#34;
        lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, func_type, f&#34;D.{returnDigit}&#34;)))

    return lines

def returnLines(node,returnDigit,labelDigit,successDigit=None,failureDigit=None):
    &#34;&#34;&#34;
    Produces a linear representation of the content nested within `node`.

    Args:
        node: The AST node.
        returnDigit: The variable to store the return value.
        labelDigit: A list of all previously used label values.
        successDigit: The label value to jump to if there is a `continue`.
        failureDigit: The label value to jump to if there is a `break`.
        prefix: The string prefix for indenting the given line.

    Returns:
        lines: The lines produced from the content.
        labelDigit: The list of all used label values.
    &#34;&#34;&#34;
    lines = []
    if node.name == &#34;body&#34;:
        il = [x.children[0] for x in node.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]

        # It is the scopes responsibility to ensure that the content is wrapped in braces
        if il:
            for x in il:
                modifiers = f&#34;{&#39; &#39;.join([y.name for y in x.children[0].children])}{&#39; &#39; if [y.name for y in x.children[0].children] else &#39;&#39;}&#34;
                lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, x.children[0].name, x.children[1].name), [labelDigit]))

    for element in node.children:
        try:
            splits = [[&#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;, &#34;=&#34;],[&#34;for&#34;],[&#34;body&#34;],[&#34;branch&#34;],[&#34;return&#34;],[&#34;call&#34;],[&#34;while&#34;, &#34;do_while&#34;],[&#34;break&#34;],[&#34;continue&#34;],[&#34;goto&#34;],[&#34;label&#34;], [&#34;++&#34;, &#34;--&#34;]]
            ind = [splits.index(x) for x in splits if element.name in x]
            ind = ind[0]
            if ind == 0:
                line = irl.IRLine(element, tvs=[], labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                if labelList != []:
                    labelDigit = labelList[-1]

            elif ind == 1:
                # For Loop
                ns = False
                # Initialize variable
                if element.children[0].children != []:
                    initNode = ast.ASTNode(&#34;body&#34;, None)
                    initNode.children.append(element.children[0])
                    if [x.children[0] for x in initNode.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Keep track of label for conditional block (if conditional exist)
                conditionLabel = None
                if element.children[1].children != []:

                    # Append an IRGoTo node
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    conditionLabel = labelDigit
                    labelDigit += 1

                # Append an IRJump node for the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[3], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                # Add the &#34;end-of-loop&#34; assignment/arithmetic
                if element.children[2].children != []:
                    initNode = ast.ASTNode(&#34;tmp&#34;, None)
                    initNode.children.append(element.children[2])
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Start of conditionals for the loop
                if conditionLabel != None:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                    tmpNode = element.children[1]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[1])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1]

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                else:
                    # No conditional (jump to start of body...always True)
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{loopStart}&gt;&#34;), [labelDigit]))

                # increment twice for new index
                labelDigit += 2

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 2:
                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))

                tmp, labelDigit = returnLines(element, returnDigit, labelDigit, successDigit, failureDigit)
                lines.extend(tmp)

                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 3:
                # If/Else statement(s)

                # list of goto labels to be appended at end of if blocks
                end_if = []

                #for each case in a branch
                for case in element.children:
                    ns = False
                    #create label for body if true and label to skip to correct place if false.
                    success_label = labelDigit
                    labelDigit += 1
                    failure_label = labelDigit
                    labelDigit += 1

                    #default is an &#39;else&#39;. Only has one child, body
                    if case.name == &#34;default&#34;:
                        if [x.children[0] for x in case.children[0].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                            ns = True

                        #Get lines for the body and assign new labeldigit
                        tmp, labelDigit = returnLines(case.children[0], returnDigit, labelDigit, success_label, failure_label)
                        lines.extend(tmp)

                        if ns:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                        break

                    tmpNode = case.children[0]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(case.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    #break down argument for if statement into smaller if statements
                    line = irl.IRLine(tmpNode, tvs=[], success=success_label, failure=failure_label, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1


                    #Add goto for body statement
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{success_label}&gt;&#34;), [labelDigit]))

                    if [x.children[0] for x in case.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                    #Get lines for the if body and assign new labeldigit
                    tmp, labelDigit = returnLines(case.children[1], returnDigit,  labelDigit, success_label, failure_label)
                    lines.extend(tmp)

                    if ns:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                    #append goto for end of if body
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    end_if.append(labelDigit)
                    labelDigit += 1

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{failure_label}&gt;&#34;), [labelDigit]))

                for i in end_if:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{i}&gt;&#34;), [labelDigit]))

            elif ind == 4:
                #Return

                # If returns some type of arithmetic expression, breaks it down.
                if len(element.children) &gt; 0 and element.children[0].children != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    if line.treeList != []:
                        lines.append(line)
                        lines[-1].treeList.append(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;))

                    else:
                        lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;), [labelDigit]))
                    
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                    if labelList != []:
                        labelDigit = labelList[-1]

                elif len(element.children) &gt; 0 and element.children[0].children == []:
                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{element.children[0].name}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                # Returns nothing
                else:
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(None), [labelDigit]))

            elif ind == 5:
                #Function Call
                func_call = element.children[0].name

                # function call has parameters
                if element.children[0] != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1

                # no parameters
                else:
                    # Append Empty function call node
                    lines.append(irl.IRLine.singleEntry(irl.IRFunctionCall(func_call, None), [labelDigit]))

            elif ind == 6:
                #While and Do While

                ns = False

                # Jump straight to conditionals for only &#39;While&#39; statements
                if element.name == &#34;while&#34;:
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Keep track of label for conditional block
                conditionLabel = labelDigit
                labelDigit += 1

                # Add the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                if [x.children[0] for x in element.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[1], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                # Start of conditionals for the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                tmpNode = element.children[0]
                if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                if labelList != []:
                    labelDigit = labelList[-1]
                # increment twice for new index (twce, in case it was a do while)
                labelDigit += 2

            elif ind == 7:
                # Break
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{failureDigit}&gt;&#34;), [labelDigit]))

            elif ind == 8:
                # Continue
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{successDigit}&gt;&#34;), [labelDigit]))

            elif ind == 9:
                # Goto
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;{element.children[0].name}&#34;), [labelDigit]))
            elif ind == 10:
                # Jump Label
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;{element.children[0].name}&#34;), [labelDigit]))

                if (len(element.children) &gt; 1):
                    temp_lines, labelDigit = returnLines(element.children[1], returnDigit, labelDigit)

                    lines.extend(temp_lines)

            elif ind == 11:
                # Special assignment? (++, --)
                line = irl.IRLine(element, tvs=[])
                tvs, labelList = line.retrieve()
                lines.append(line)

            else:
                pass
                # print(&#34;Unsupported at this time&#34;)

        except Warning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            # print(exc_type, exc_tb.tb_lineno)
            pass

    return lines, labelDigit</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.beginWrapper"><code class="name flex">
<span>def <span class="ident">beginWrapper</span></span>(<span>function_tuple, returnDigit)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces the function wrappers and initializes the return digit for the given function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lines</code></strong></dt>
<dd>The lines of the start of the function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beginWrapper(function_tuple, returnDigit):
    &#34;&#34;&#34;
    Produces the function wrappers and initializes the return digit for the given function.

    Returns:
        lines: The lines of the start of the function
    &#34;&#34;&#34;
    lines = []
    params = &#34;&#34;
    func_type = function_tuple[0].children[0].name
    func_name = function_tuple[0].children[1].name

    for var in function_tuple[0].children[2].children:
        if var.name == &#34;var&#34;:
            params += f&#34;{var.children[0].name} {var.children[1].name},&#34;

    lines.append(irl.IRLine.singleEntry(irl.IRFunctionDecl(func_name, params[:-1])))
    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True)))

    if func_type != &#34;void&#34;:
        modifiers = f&#34;{&#39;&#39;.join([x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]])}{&#39; &#39; if [x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]] else &#39;&#39;}&#34;
        lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, func_type, f&#34;D.{returnDigit}&#34;)))

    return lines</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.buildBoilerPlate"><code class="name flex">
<span>def <span class="ident">buildBoilerPlate</span></span>(<span>symTable)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildBoilerPlate(symTable):
    namesandparams = []
    functionNames = [(x.name,x.type) for x in symTable.symbols if x.is_function]
    params = [(x.name,x.scope,x.type) for x in symTable.symbols if x.is_param]

    for x in functionNames:
        track = 0
        paramsLi = []
        for i in params:
            if x[0] == i[1].split(&#34;/&#34;)[1]:
                track+=1

                paramsLi.append((i[2],i[0]))
        if track == 0:
            namesandparams.append((x[0],paramsLi,x[1]))
        else:
            namesandparams.append((x[0],paramsLi,x[1]))
    return namesandparams</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.returnLines"><code class="name flex">
<span>def <span class="ident">returnLines</span></span>(<span>node, returnDigit, labelDigit, successDigit=None, failureDigit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces a linear representation of the content nested within <code>node</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node.</dd>
<dt><strong><code>returnDigit</code></strong></dt>
<dd>The variable to store the return value.</dd>
<dt><strong><code>labelDigit</code></strong></dt>
<dd>A list of all previously used label values.</dd>
<dt><strong><code>successDigit</code></strong></dt>
<dd>The label value to jump to if there is a <code>continue</code>.</dd>
<dt><strong><code>failureDigit</code></strong></dt>
<dd>The label value to jump to if there is a <code>break</code>.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The string prefix for indenting the given line.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lines</code></strong></dt>
<dd>The lines produced from the content.</dd>
<dt><strong><code>labelDigit</code></strong></dt>
<dd>The list of all used label values.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returnLines(node,returnDigit,labelDigit,successDigit=None,failureDigit=None):
    &#34;&#34;&#34;
    Produces a linear representation of the content nested within `node`.

    Args:
        node: The AST node.
        returnDigit: The variable to store the return value.
        labelDigit: A list of all previously used label values.
        successDigit: The label value to jump to if there is a `continue`.
        failureDigit: The label value to jump to if there is a `break`.
        prefix: The string prefix for indenting the given line.

    Returns:
        lines: The lines produced from the content.
        labelDigit: The list of all used label values.
    &#34;&#34;&#34;
    lines = []
    if node.name == &#34;body&#34;:
        il = [x.children[0] for x in node.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]

        # It is the scopes responsibility to ensure that the content is wrapped in braces
        if il:
            for x in il:
                modifiers = f&#34;{&#39; &#39;.join([y.name for y in x.children[0].children])}{&#39; &#39; if [y.name for y in x.children[0].children] else &#39;&#39;}&#34;
                lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, x.children[0].name, x.children[1].name), [labelDigit]))

    for element in node.children:
        try:
            splits = [[&#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;, &#34;=&#34;],[&#34;for&#34;],[&#34;body&#34;],[&#34;branch&#34;],[&#34;return&#34;],[&#34;call&#34;],[&#34;while&#34;, &#34;do_while&#34;],[&#34;break&#34;],[&#34;continue&#34;],[&#34;goto&#34;],[&#34;label&#34;], [&#34;++&#34;, &#34;--&#34;]]
            ind = [splits.index(x) for x in splits if element.name in x]
            ind = ind[0]
            if ind == 0:
                line = irl.IRLine(element, tvs=[], labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                if labelList != []:
                    labelDigit = labelList[-1]

            elif ind == 1:
                # For Loop
                ns = False
                # Initialize variable
                if element.children[0].children != []:
                    initNode = ast.ASTNode(&#34;body&#34;, None)
                    initNode.children.append(element.children[0])
                    if [x.children[0] for x in initNode.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Keep track of label for conditional block (if conditional exist)
                conditionLabel = None
                if element.children[1].children != []:

                    # Append an IRGoTo node
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    conditionLabel = labelDigit
                    labelDigit += 1

                # Append an IRJump node for the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[3], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                # Add the &#34;end-of-loop&#34; assignment/arithmetic
                if element.children[2].children != []:
                    initNode = ast.ASTNode(&#34;tmp&#34;, None)
                    initNode.children.append(element.children[2])
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Start of conditionals for the loop
                if conditionLabel != None:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                    tmpNode = element.children[1]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[1])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1]

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                else:
                    # No conditional (jump to start of body...always True)
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{loopStart}&gt;&#34;), [labelDigit]))

                # increment twice for new index
                labelDigit += 2

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 2:
                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))

                tmp, labelDigit = returnLines(element, returnDigit, labelDigit, successDigit, failureDigit)
                lines.extend(tmp)

                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 3:
                # If/Else statement(s)

                # list of goto labels to be appended at end of if blocks
                end_if = []

                #for each case in a branch
                for case in element.children:
                    ns = False
                    #create label for body if true and label to skip to correct place if false.
                    success_label = labelDigit
                    labelDigit += 1
                    failure_label = labelDigit
                    labelDigit += 1

                    #default is an &#39;else&#39;. Only has one child, body
                    if case.name == &#34;default&#34;:
                        if [x.children[0] for x in case.children[0].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                            ns = True

                        #Get lines for the body and assign new labeldigit
                        tmp, labelDigit = returnLines(case.children[0], returnDigit, labelDigit, success_label, failure_label)
                        lines.extend(tmp)

                        if ns:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                        break

                    tmpNode = case.children[0]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(case.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    #break down argument for if statement into smaller if statements
                    line = irl.IRLine(tmpNode, tvs=[], success=success_label, failure=failure_label, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1


                    #Add goto for body statement
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{success_label}&gt;&#34;), [labelDigit]))

                    if [x.children[0] for x in case.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                    #Get lines for the if body and assign new labeldigit
                    tmp, labelDigit = returnLines(case.children[1], returnDigit,  labelDigit, success_label, failure_label)
                    lines.extend(tmp)

                    if ns:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                    #append goto for end of if body
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    end_if.append(labelDigit)
                    labelDigit += 1

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{failure_label}&gt;&#34;), [labelDigit]))

                for i in end_if:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{i}&gt;&#34;), [labelDigit]))

            elif ind == 4:
                #Return

                # If returns some type of arithmetic expression, breaks it down.
                if len(element.children) &gt; 0 and element.children[0].children != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    if line.treeList != []:
                        lines.append(line)
                        lines[-1].treeList.append(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;))

                    else:
                        lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;), [labelDigit]))
                    
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                    if labelList != []:
                        labelDigit = labelList[-1]

                elif len(element.children) &gt; 0 and element.children[0].children == []:
                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{element.children[0].name}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                # Returns nothing
                else:
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(None), [labelDigit]))

            elif ind == 5:
                #Function Call
                func_call = element.children[0].name

                # function call has parameters
                if element.children[0] != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1

                # no parameters
                else:
                    # Append Empty function call node
                    lines.append(irl.IRLine.singleEntry(irl.IRFunctionCall(func_call, None), [labelDigit]))

            elif ind == 6:
                #While and Do While

                ns = False

                # Jump straight to conditionals for only &#39;While&#39; statements
                if element.name == &#34;while&#34;:
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Keep track of label for conditional block
                conditionLabel = labelDigit
                labelDigit += 1

                # Add the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                if [x.children[0] for x in element.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[1], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                # Start of conditionals for the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                tmpNode = element.children[0]
                if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                if labelList != []:
                    labelDigit = labelList[-1]
                # increment twice for new index (twce, in case it was a do while)
                labelDigit += 2

            elif ind == 7:
                # Break
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{failureDigit}&gt;&#34;), [labelDigit]))

            elif ind == 8:
                # Continue
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{successDigit}&gt;&#34;), [labelDigit]))

            elif ind == 9:
                # Goto
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;{element.children[0].name}&#34;), [labelDigit]))
            elif ind == 10:
                # Jump Label
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;{element.children[0].name}&#34;), [labelDigit]))

                if (len(element.children) &gt; 1):
                    temp_lines, labelDigit = returnLines(element.children[1], returnDigit, labelDigit)

                    lines.extend(temp_lines)

            elif ind == 11:
                # Special assignment? (++, --)
                line = irl.IRLine(element, tvs=[])
                tvs, labelList = line.retrieve()
                lines.append(line)

            else:
                pass
                # print(&#34;Unsupported at this time&#34;)

        except Warning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            # print(exc_type, exc_tb.tb_lineno)
            pass

    return lines, labelDigit</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR"><code class="flex name class">
<span>class <span class="ident">LevelOneIR</span></span>
<span>(</span><span>astHead, symTable)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>astHead</code></strong></dt>
<dd>The root node of the AST</dd>
<dt><strong><code>symTable</code></strong></dt>
<dd>The symbol table for the input</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LevelOneIR():
    &#34;&#34;&#34;
    Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.
    &#34;&#34;&#34;
    def __init__(self,astHead,symTable):
        &#34;&#34;&#34;
        Args:
            astHead: The root node of the AST
            symTable: The symbol table for the input
        &#34;&#34;&#34;
        self.astHead = astHead
        self.symTable = symTable
        self.IR = []

    def construct(self):
        &#34;&#34;&#34;
        Constructs the linear representation for the object.

        Returns:
            IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
        &#34;&#34;&#34;
        sym = self.symTable
        ntv = self.astHead

        varIndex = 0
        lastVarName = &#34;_&#34; + str(varIndex)
        bodyList = []

        # list of all bodies within functions in our C program
        for x in self.astHead.children:
            if x.name == &#34;func&#34;:
                # Each entry is the &#39;(func_node, body_node)&#39;
                bodyList.append((x,x.children[3]))

        returnDigit = 1234
        labelDigit = returnDigit + 1
        lines = []

        for i in bodyList:
            # Beginning of fuction wrapper
            lines.extend(beginWrapper(i, returnDigit))

            # Body of function
            tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
            lines.extend(tmp_lines)

            # End of function wrapper, add closing bracket
            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

            # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
            returnDigit = labelDigit

            self.IR = lines

        return self.IR


    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in self.IR]) + &#34;\n&#34;

    def optimize(self, opt):
        if opt &gt; 0:
            self.remove_unused_funcs()
            self.remove_unused_vars()
            pass

        if opt &gt; 1:
            # A dictionary containing all the values of variables that can at some point be reduced.
            self.var_values = {
                func.name : {
                    var.name : &#34;Undef&#34;
                    for var in self.symTable.symbols if var.entry_type == 0 and var.scope.startswith(f&#34;/{func.name}&#34;)
                }
                for func in [sym for sym in self.symTable.symbols if sym.entry_type == 1]
            }

            # NOTE: As a method of knowing whether it is safe to continue on to the next node in the list the following measures have been implemented:
            # Both constant folding and constant propagation only consider a singular value.
            # They both return a boolean describing whether the node was altered as well as some descriptor of what it did.
                # In the case of constant folding, the descriptor is the new simplified node which then has to be assigned to the correct index.
                # In the case of constant propagation, the descriptor is a dictionary containing the updated values relevant to the scope of the IRLine object meaning that tempoary variables are stored within the IRLine but now within the scope as a whole.
            # The idea is that while either of these methods can alter the node you keep executing them on the node so that if the loop terminates the program is sure that the node cannot be reduced further.
            # Another final optimization that can be done would be to check if all the nodes in an IRLine object are `IRAssignment`, if so the last one is the only `IRAssignment` node needed, and the others can be removed.

            prev_maj = 0
            cur_scope = &#34;&#34;
            tmp_vals = {}
            for major, minor, node in [(major, minor, node) for major, tl in enumerate(self.IR) for minor, node in enumerate(tl.treeList)]:
                if major != prev_maj:
                    tmp_vals = {}

                if isinstance(node, irl.IRFunctionDecl):
                    cur_scope = node.name
                elif isinstance(node, irl.IRGoTo) or isinstance(node, irl.IRJump) or isinstance(node, irl.IRIf):
                    for val in tmp_vals.items():
                        if val[0] in self.var_values[cur_scope]:
                            self.var_values[cur_scope][val[0]] = &#34;Undef&#34;
                        tmp_vals[val[0]] = &#34;Undef&#34;
                else:
                    for val in self.var_values[cur_scope].items():
                        tmp_vals[val[0]] = val[1]

                ncf = False
                ncp = False

                while 1:
                    ncf, tmp = self.constant_folding(node)

                    if ncf:
                        self.IR[major].treeList[minor] = tmp
                        node = tmp

                    ncp, vals = self.constant_propagation(node, tmp_vals)

                    for val in vals.items():
                        if val[0] in self.var_values[cur_scope]:
                            self.var_values[cur_scope][val[0]] = val[1]
                        tmp_vals[val[0]] = val[1]

                    if not (ncf or ncp):
                        break
                prev_maj = major

            self.cleanup()

    def remove_unused_vars(self):
        ir = self.IR
        scope = &#34;&#34;

        #get variables to remove
        vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
        #get function from symbol table.
        funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

        final_ir = []

        for irLine in ir:

            for idx, irNode in enumerate(irLine.treeList):
                #check if function declaration, to set new scope
                if isinstance(irNode, irl.IRFunctionDecl):
                    scope = irNode.name

                #check if declaration
                if isinstance(irNode, irl.IRVariableInit):
                    #check if variable needs to be skippped
                    if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                        del irLine.treeList[idx]

                #check if usage
                elif(isinstance(irNode, irl.IRAssignment)):
                    if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                        del irLine.treeList[idx]

            #irLine has no irNode inside...so we dont add it to new IR list
            if irLine.treeList == []:
                pass
            else:
                final_ir.append(irLine)


        self.IR = final_ir

    def cleanup(self):

        class ref():
            def __init__(self, init_index, init_ref_type, side):
                self.refs = [init_index]
                self.ref_types = [init_ref_type]
                self.side = [side]

            def add(self, index, ref_type, side):
                self.refs.append(index)
                self.ref_types.append(ref_type)
                self.side.append(side)

            def __str__(self):
                return f&#34;\t{self.refs}\t{self.ref_types}\t{self.side}&#34;

            def __repr__(self):
                return self.__str__()

        gr = {}
        for line in self.IR:
            lr = {}

            for i, node in enumerate(line.treeList):
                if isinstance(node, irl.IRAssignment):
                    if node.lhs in lr:
                        lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                    tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.rhs in lr and not tmp.isnumeric():
                        lr[node.rhs].add(i, &#34;assignment&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.rhs] = ref(i, &#34;assignment&#34;, 1)
                elif isinstance(node, irl.IRArth):
                    if node.var in lr:
                        lr[node.var].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.var] = ref(i, &#34;assignment&#34;, 0)

                    tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.lhs in lr and not tmp.isnumeric():
                        lr[node.lhs].add(i, &#34;arithmetic&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.lhs] = ref(i, &#34;arithmetic&#34;, 1)

                    if node.rhs:
                        tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if node.rhs in lr and not tmp.isnumeric():
                            lr[node.rhs].add(i, &#34;arithmetic&#34;, 2)
                        elif not tmp.isnumeric():
                            lr[node.rhs] = ref(i, &#34;arithmetic&#34;, 2)
                elif isinstance(node, irl.IRFunctionAssign):
                    if node.lhs in lr:
                        lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                    else:
                        lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                    for param in node.params:
                        tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if param in lr and not tmp.isnumeric():
                            lr[node.lhs].add(i, &#34;param&#34;, 1)
                        elif not tmp.isnumeric():
                            lr[node.lhs] = ref(i, &#34;param&#34;, 1)
                elif isinstance(node, irl.IRIf):
                    tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.lhs in lr and not tmp.isnumeric():
                        lr[node.lhs].add(i, &#34;collation&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.lhs] = ref(i, &#34;collation&#34;, 1)

                    tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.rhs in lr and not tmp.isnumeric():
                        lr[node.rhs].add(i, &#34;collation&#34;, 2)
                    elif not tmp.isnumeric():
                        lr[node.rhs] = ref(i, &#34;collation&#34;, 2)
                elif isinstance(node, irl.IRSpecial):
                    if node.var in lr:
                        lr[node.var].add(i, &#34;assignment&#34;, 0)
                        lr[node.var].add(i, &#34;assignment&#34;, 1)
                    else:
                        lr[node.var] = ref(i, &#34;assignment&#34;, 0)
                        lr[node.var].add(i, &#34;assignment&#34;, 1)
                elif isinstance(node, irl.IRReturn):
                    if node.value:
                        tmp = node.value.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                        if node.value in lr:
                            lr[node.value].add(i, &#34;return&#34;, 0)
                        elif not tmp.isnumeric():
                            lr[node.value] = ref(i, &#34;return&#34;, 0)
            rem_list = []

            for var in lr.items():
                # print(var)
                for i, typ in enumerate(var[1].ref_types):
                    if (
                        i+1 &lt; len(var[1].ref_types)
                        and
                        typ == &#34;assignment&#34;
                        and
                        var[1].side[i] == 0
                        and
                        var[1].side[i+1] == 0
                        and
                        var[1].ref_types[i+1] == &#34;assignment&#34;
                        ):
                        rem_list.append(var[1].refs[i])
                    elif (
                        i+1 == len(var[1].ref_types)
                        and
                        typ == &#34;assignment&#34;
                        and
                        var[1].side[i] == 0
                        # and
                        # var[1].side[i+1] == 0
                        and
                        (
                            var[1].refs[i]+1 != len(line.treeList)
                            or
                            len(var[1].ref_types) &gt; 1)
                        ):
                        rem_list.append(var[1].refs[i])

                # iterate over reference types and see if there are two assignments after each other.


            for node in reversed(sorted(rem_list)):
                line.treeList.pop(node)

    def remove_unused_funcs(self):
        ir = self.IR
        inFunction = False
        to_remove = []

        for idx, irLine in enumerate(ir):

            # Only need to focus on first Node in each IRLine
            ir_firstNode = irLine.treeList[0]

            # Delete IRLine if we are in a &#39;unused&#39; function
            # Mark &#39;inFunction&#39; to False if beginning of new function
            if inFunction == True:
                if isinstance(ir_firstNode, irl.IRFunctionDecl):
                    inFunction = False
                else:
                    to_remove.append(idx)
                    continue

            # Check for function
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                func_name = ir_firstNode.name
                referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])

                # If reference is 0, it is unused
                if referenceNum == 0 and func_name != &#34;main&#34;:
                    to_remove.append(idx)
                    inFunction = True

        # Actually delete unused function IRLine&#39;s
        for i in to_remove[::-1]:
            del ir[i]


        self.IR = ir

    def constant_folding(self,x):
        changed = False
        if isinstance(x,irl.IRArth):
            notFound = True
            op = False
            #get the operator being used
            if(x.rhs != None and x.lhs != None):
                if(x.operator == &#34;+&#34;):
                    op = lambda lhs, rhs : lhs + rhs
                elif(x.operator == &#34;-&#34;):
                    op = lambda lhs, rhs : lhs - rhs
                elif(x.operator == &#34;*&#34;):
                    op = lambda lhs, rhs : lhs * rhs
                elif(x.operator == &#34;/&#34;):
                    op = lambda lhs, rhs : lhs / rhs
                elif(x.operator == &#34;%&#34;):
                    op = lambda lhs, rhs : math.fmod(lhs, rhs)
                elif(x.operator == &#34;&lt;&lt;&#34;):
                    # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &lt;&lt; 31 compared to 10 &lt;&lt; 20
                    op = lambda lhs, rhs : lhs &lt;&lt; rhs
                elif(x.operator == &#34;&gt;&gt;&#34;):
                    # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &gt;&gt; 31 compared to 10 &gt;&gt; 20
                    op = lambda lhs, rhs : lhs &gt;&gt; rhs
                elif(x.operator == &#34;|&#34;):
                    op = lambda lhs, rhs : lhs | rhs
                elif(x.operator == &#34;&amp;&#34;):
                    op = lambda lhs, rhs : lhs &amp; rhs
                elif(x.operator == &#34;^&#34;):
                    op = lambda lhs, rhs : lhs ^ rhs
            else:
                if(x.operator == &#34;~&#34;):
                    op = lambda lhs, rhs : ~lhs
                elif(x.operator == &#34;-&#34;):
                    op = lambda lhs, rhs : 0 - lhs
                elif(x.operator == &#34;+&#34;):
                    op = lambda lhs, rhs : 0 + lhs
                elif(x.operator == &#34;!&#34;):
                    op = lambda lhs, rhs : not lhs
            #get the left hand side and the right hand side
            try:
                lhs = int(x.lhs)
                if(not x.rhs == None):
                    rhs = int(x.rhs)
                else:
                    rhs = None
                notFound = False
            except ValueError:
                try:
                    lhs = float(x.lhs)
                    if(not x.rhs == None):
                        rhs = float(x.rhs)
                    else:
                        rhs = None
                    notFound = False
                except ValueError:
                    pass

            #if we found all components, replace the node
            if(not notFound and op):
                if rhs and rhs &lt; 0:
                    if x.operator == &#34;&lt;&lt;&#34; or x.operator == &#34;&gt;&gt;&#34;:
                        raise ValueError(&#34;shifting by negative number is undefined behavior.&#34;)

                newValue = lambda lhs, rhs, op : op(lhs,rhs)
                val = newValue(lhs,rhs,op) if isinstance(lhs, float) or isinstance(rhs, float) else math.floor(newValue(lhs,rhs,op))
                newAss = irl.IRAssignment(x.var, str(val))
                changed = True
                return changed,newAss
        return changed,x

    def constant_propagation(self, node, var_val):

        # NOTE: The current issue is that the propogation is goint to have to exit and re enter the function every time to achieve the following:
        # Clear the tempoary variables per line as they are re used
        # Avoid propogating too far so that assignments in the future that may happen after certain other computations and assignments propogate the correct value

        # TODO: Fix to detect whether the reference is necessary or not. Eg, comparisons in loops compared to simple ifs
        # TODO: Ensure that when comming across a value that is not computable or propogatable such as after some control flow, the dictionary value becomes something distinguisable so that the expression is left alone
        changed = False
        if isinstance(node, irl.IRIf):
            if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
                node.lhs = var_val[node.lhs]
                changed = True
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                changed = True

        elif isinstance(node, irl.IRArth):
            if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
                node.lhs = var_val[node.lhs]
                changed = True
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                changed = True

        elif isinstance(node, irl.IRSpecial):
            pass
            # Assigning a value for a post and pre increment is extremly difficult due to the fact that it regularly occurs in loops and constants arent useful there.

        elif isinstance(node, irl.IRAssignment):
            if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
                node.rhs = var_val[node.rhs]
                var_val[node.lhs] = node.rhs
                changed = True
            else:
                tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if tmp.isnumeric():
                    var_val[node.lhs] = node.rhs

        elif isinstance(node, irl.IRFunctionAssign):
            for j, param in enumerate(node.params):
                if param in var_val and var_val[param] != None:
                    node.params[j] = var_val[param]
                    changed = True

        return changed, var_val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):

    class ref():
        def __init__(self, init_index, init_ref_type, side):
            self.refs = [init_index]
            self.ref_types = [init_ref_type]
            self.side = [side]

        def add(self, index, ref_type, side):
            self.refs.append(index)
            self.ref_types.append(ref_type)
            self.side.append(side)

        def __str__(self):
            return f&#34;\t{self.refs}\t{self.ref_types}\t{self.side}&#34;

        def __repr__(self):
            return self.__str__()

    gr = {}
    for line in self.IR:
        lr = {}

        for i, node in enumerate(line.treeList):
            if isinstance(node, irl.IRAssignment):
                if node.lhs in lr:
                    lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                else:
                    lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if node.rhs in lr and not tmp.isnumeric():
                    lr[node.rhs].add(i, &#34;assignment&#34;, 1)
                elif not tmp.isnumeric():
                    lr[node.rhs] = ref(i, &#34;assignment&#34;, 1)
            elif isinstance(node, irl.IRArth):
                if node.var in lr:
                    lr[node.var].add(i, &#34;assignment&#34;, 0)
                else:
                    lr[node.var] = ref(i, &#34;assignment&#34;, 0)

                tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if node.lhs in lr and not tmp.isnumeric():
                    lr[node.lhs].add(i, &#34;arithmetic&#34;, 1)
                elif not tmp.isnumeric():
                    lr[node.lhs] = ref(i, &#34;arithmetic&#34;, 1)

                if node.rhs:
                    tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.rhs in lr and not tmp.isnumeric():
                        lr[node.rhs].add(i, &#34;arithmetic&#34;, 2)
                    elif not tmp.isnumeric():
                        lr[node.rhs] = ref(i, &#34;arithmetic&#34;, 2)
            elif isinstance(node, irl.IRFunctionAssign):
                if node.lhs in lr:
                    lr[node.lhs].add(i, &#34;assignment&#34;, 0)
                else:
                    lr[node.lhs] = ref(i, &#34;assignment&#34;, 0)

                for param in node.params:
                    tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if param in lr and not tmp.isnumeric():
                        lr[node.lhs].add(i, &#34;param&#34;, 1)
                    elif not tmp.isnumeric():
                        lr[node.lhs] = ref(i, &#34;param&#34;, 1)
            elif isinstance(node, irl.IRIf):
                tmp = node.lhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if node.lhs in lr and not tmp.isnumeric():
                    lr[node.lhs].add(i, &#34;collation&#34;, 1)
                elif not tmp.isnumeric():
                    lr[node.lhs] = ref(i, &#34;collation&#34;, 1)

                tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                if node.rhs in lr and not tmp.isnumeric():
                    lr[node.rhs].add(i, &#34;collation&#34;, 2)
                elif not tmp.isnumeric():
                    lr[node.rhs] = ref(i, &#34;collation&#34;, 2)
            elif isinstance(node, irl.IRSpecial):
                if node.var in lr:
                    lr[node.var].add(i, &#34;assignment&#34;, 0)
                    lr[node.var].add(i, &#34;assignment&#34;, 1)
                else:
                    lr[node.var] = ref(i, &#34;assignment&#34;, 0)
                    lr[node.var].add(i, &#34;assignment&#34;, 1)
            elif isinstance(node, irl.IRReturn):
                if node.value:
                    tmp = node.value.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
                    if node.value in lr:
                        lr[node.value].add(i, &#34;return&#34;, 0)
                    elif not tmp.isnumeric():
                        lr[node.value] = ref(i, &#34;return&#34;, 0)
        rem_list = []

        for var in lr.items():
            # print(var)
            for i, typ in enumerate(var[1].ref_types):
                if (
                    i+1 &lt; len(var[1].ref_types)
                    and
                    typ == &#34;assignment&#34;
                    and
                    var[1].side[i] == 0
                    and
                    var[1].side[i+1] == 0
                    and
                    var[1].ref_types[i+1] == &#34;assignment&#34;
                    ):
                    rem_list.append(var[1].refs[i])
                elif (
                    i+1 == len(var[1].ref_types)
                    and
                    typ == &#34;assignment&#34;
                    and
                    var[1].side[i] == 0
                    # and
                    # var[1].side[i+1] == 0
                    and
                    (
                        var[1].refs[i]+1 != len(line.treeList)
                        or
                        len(var[1].ref_types) &gt; 1)
                    ):
                    rem_list.append(var[1].refs[i])

            # iterate over reference types and see if there are two assignments after each other.


        for node in reversed(sorted(rem_list)):
            line.treeList.pop(node)</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_folding"><code class="name flex">
<span>def <span class="ident">constant_folding</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constant_folding(self,x):
    changed = False
    if isinstance(x,irl.IRArth):
        notFound = True
        op = False
        #get the operator being used
        if(x.rhs != None and x.lhs != None):
            if(x.operator == &#34;+&#34;):
                op = lambda lhs, rhs : lhs + rhs
            elif(x.operator == &#34;-&#34;):
                op = lambda lhs, rhs : lhs - rhs
            elif(x.operator == &#34;*&#34;):
                op = lambda lhs, rhs : lhs * rhs
            elif(x.operator == &#34;/&#34;):
                op = lambda lhs, rhs : lhs / rhs
            elif(x.operator == &#34;%&#34;):
                op = lambda lhs, rhs : math.fmod(lhs, rhs)
            elif(x.operator == &#34;&lt;&lt;&#34;):
                # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &lt;&lt; 31 compared to 10 &lt;&lt; 20
                op = lambda lhs, rhs : lhs &lt;&lt; rhs
            elif(x.operator == &#34;&gt;&gt;&#34;):
                # There is an edge case around the changes of architectures so that values may differ depending on the architecture you are using. eg 10 &gt;&gt; 31 compared to 10 &gt;&gt; 20
                op = lambda lhs, rhs : lhs &gt;&gt; rhs
            elif(x.operator == &#34;|&#34;):
                op = lambda lhs, rhs : lhs | rhs
            elif(x.operator == &#34;&amp;&#34;):
                op = lambda lhs, rhs : lhs &amp; rhs
            elif(x.operator == &#34;^&#34;):
                op = lambda lhs, rhs : lhs ^ rhs
        else:
            if(x.operator == &#34;~&#34;):
                op = lambda lhs, rhs : ~lhs
            elif(x.operator == &#34;-&#34;):
                op = lambda lhs, rhs : 0 - lhs
            elif(x.operator == &#34;+&#34;):
                op = lambda lhs, rhs : 0 + lhs
            elif(x.operator == &#34;!&#34;):
                op = lambda lhs, rhs : not lhs
        #get the left hand side and the right hand side
        try:
            lhs = int(x.lhs)
            if(not x.rhs == None):
                rhs = int(x.rhs)
            else:
                rhs = None
            notFound = False
        except ValueError:
            try:
                lhs = float(x.lhs)
                if(not x.rhs == None):
                    rhs = float(x.rhs)
                else:
                    rhs = None
                notFound = False
            except ValueError:
                pass

        #if we found all components, replace the node
        if(not notFound and op):
            if rhs and rhs &lt; 0:
                if x.operator == &#34;&lt;&lt;&#34; or x.operator == &#34;&gt;&gt;&#34;:
                    raise ValueError(&#34;shifting by negative number is undefined behavior.&#34;)

            newValue = lambda lhs, rhs, op : op(lhs,rhs)
            val = newValue(lhs,rhs,op) if isinstance(lhs, float) or isinstance(rhs, float) else math.floor(newValue(lhs,rhs,op))
            newAss = irl.IRAssignment(x.var, str(val))
            changed = True
            return changed,newAss
    return changed,x</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_propagation"><code class="name flex">
<span>def <span class="ident">constant_propagation</span></span>(<span>self, node, var_val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constant_propagation(self, node, var_val):

    # NOTE: The current issue is that the propogation is goint to have to exit and re enter the function every time to achieve the following:
    # Clear the tempoary variables per line as they are re used
    # Avoid propogating too far so that assignments in the future that may happen after certain other computations and assignments propogate the correct value

    # TODO: Fix to detect whether the reference is necessary or not. Eg, comparisons in loops compared to simple ifs
    # TODO: Ensure that when comming across a value that is not computable or propogatable such as after some control flow, the dictionary value becomes something distinguisable so that the expression is left alone
    changed = False
    if isinstance(node, irl.IRIf):
        if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
            node.lhs = var_val[node.lhs]
            changed = True
        if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
            node.rhs = var_val[node.rhs]
            changed = True

    elif isinstance(node, irl.IRArth):
        if node.lhs in var_val and var_val[node.lhs] != &#34;Undef&#34;:
            node.lhs = var_val[node.lhs]
            changed = True
        if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
            node.rhs = var_val[node.rhs]
            changed = True

    elif isinstance(node, irl.IRSpecial):
        pass
        # Assigning a value for a post and pre increment is extremly difficult due to the fact that it regularly occurs in loops and constants arent useful there.

    elif isinstance(node, irl.IRAssignment):
        if node.rhs in var_val and var_val[node.rhs] != &#34;Undef&#34;:
            node.rhs = var_val[node.rhs]
            var_val[node.lhs] = node.rhs
            changed = True
        else:
            tmp = node.rhs.lstrip(&#39;-+&#39;).replace(&#39;.&#39;, &#39;&#39;, 1)
            if tmp.isnumeric():
                var_val[node.lhs] = node.rhs

    elif isinstance(node, irl.IRFunctionAssign):
        for j, param in enumerate(node.params):
            if param in var_val and var_val[param] != None:
                node.params[j] = var_val[param]
                changed = True

    return changed, var_val</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.construct"><code class="name flex">
<span>def <span class="ident">construct</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs the linear representation for the object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>IR</code></strong></dt>
<dd>A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct(self):
    &#34;&#34;&#34;
    Constructs the linear representation for the object.

    Returns:
        IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
    &#34;&#34;&#34;
    sym = self.symTable
    ntv = self.astHead

    varIndex = 0
    lastVarName = &#34;_&#34; + str(varIndex)
    bodyList = []

    # list of all bodies within functions in our C program
    for x in self.astHead.children:
        if x.name == &#34;func&#34;:
            # Each entry is the &#39;(func_node, body_node)&#39;
            bodyList.append((x,x.children[3]))

    returnDigit = 1234
    labelDigit = returnDigit + 1
    lines = []

    for i in bodyList:
        # Beginning of fuction wrapper
        lines.extend(beginWrapper(i, returnDigit))

        # Body of function
        tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
        lines.extend(tmp_lines)

        # End of function wrapper, add closing bracket
        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

        # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
        returnDigit = labelDigit

        self.IR = lines

    return self.IR</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self, opt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(self, opt):
    if opt &gt; 0:
        self.remove_unused_funcs()
        self.remove_unused_vars()
        pass

    if opt &gt; 1:
        # A dictionary containing all the values of variables that can at some point be reduced.
        self.var_values = {
            func.name : {
                var.name : &#34;Undef&#34;
                for var in self.symTable.symbols if var.entry_type == 0 and var.scope.startswith(f&#34;/{func.name}&#34;)
            }
            for func in [sym for sym in self.symTable.symbols if sym.entry_type == 1]
        }

        # NOTE: As a method of knowing whether it is safe to continue on to the next node in the list the following measures have been implemented:
        # Both constant folding and constant propagation only consider a singular value.
        # They both return a boolean describing whether the node was altered as well as some descriptor of what it did.
            # In the case of constant folding, the descriptor is the new simplified node which then has to be assigned to the correct index.
            # In the case of constant propagation, the descriptor is a dictionary containing the updated values relevant to the scope of the IRLine object meaning that tempoary variables are stored within the IRLine but now within the scope as a whole.
        # The idea is that while either of these methods can alter the node you keep executing them on the node so that if the loop terminates the program is sure that the node cannot be reduced further.
        # Another final optimization that can be done would be to check if all the nodes in an IRLine object are `IRAssignment`, if so the last one is the only `IRAssignment` node needed, and the others can be removed.

        prev_maj = 0
        cur_scope = &#34;&#34;
        tmp_vals = {}
        for major, minor, node in [(major, minor, node) for major, tl in enumerate(self.IR) for minor, node in enumerate(tl.treeList)]:
            if major != prev_maj:
                tmp_vals = {}

            if isinstance(node, irl.IRFunctionDecl):
                cur_scope = node.name
            elif isinstance(node, irl.IRGoTo) or isinstance(node, irl.IRJump) or isinstance(node, irl.IRIf):
                for val in tmp_vals.items():
                    if val[0] in self.var_values[cur_scope]:
                        self.var_values[cur_scope][val[0]] = &#34;Undef&#34;
                    tmp_vals[val[0]] = &#34;Undef&#34;
            else:
                for val in self.var_values[cur_scope].items():
                    tmp_vals[val[0]] = val[1]

            ncf = False
            ncp = False

            while 1:
                ncf, tmp = self.constant_folding(node)

                if ncf:
                    self.IR[major].treeList[minor] = tmp
                    node = tmp

                ncp, vals = self.constant_propagation(node, tmp_vals)

                for val in vals.items():
                    if val[0] in self.var_values[cur_scope]:
                        self.var_values[cur_scope][val[0]] = val[1]
                    tmp_vals[val[0]] = val[1]

                if not (ncf or ncp):
                    break
            prev_maj = major

        self.cleanup()</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs"><code class="name flex">
<span>def <span class="ident">remove_unused_funcs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unused_funcs(self):
    ir = self.IR
    inFunction = False
    to_remove = []

    for idx, irLine in enumerate(ir):

        # Only need to focus on first Node in each IRLine
        ir_firstNode = irLine.treeList[0]

        # Delete IRLine if we are in a &#39;unused&#39; function
        # Mark &#39;inFunction&#39; to False if beginning of new function
        if inFunction == True:
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                inFunction = False
            else:
                to_remove.append(idx)
                continue

        # Check for function
        if isinstance(ir_firstNode, irl.IRFunctionDecl):
            func_name = ir_firstNode.name
            referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])

            # If reference is 0, it is unused
            if referenceNum == 0 and func_name != &#34;main&#34;:
                to_remove.append(idx)
                inFunction = True

    # Actually delete unused function IRLine&#39;s
    for i in to_remove[::-1]:
        del ir[i]


    self.IR = ir</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars"><code class="name flex">
<span>def <span class="ident">remove_unused_vars</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unused_vars(self):
    ir = self.IR
    scope = &#34;&#34;

    #get variables to remove
    vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
    #get function from symbol table.
    funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

    final_ir = []

    for irLine in ir:

        for idx, irNode in enumerate(irLine.treeList):
            #check if function declaration, to set new scope
            if isinstance(irNode, irl.IRFunctionDecl):
                scope = irNode.name

            #check if declaration
            if isinstance(irNode, irl.IRVariableInit):
                #check if variable needs to be skippped
                if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                    del irLine.treeList[idx]

            #check if usage
            elif(isinstance(irNode, irl.IRAssignment)):
                if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                    del irLine.treeList[idx]

        #irLine has no irNode inside...so we dont add it to new IR list
        if irLine.treeList == []:
            pass
        else:
            final_ir.append(irLine)


    self.IR = final_ir</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.optimizer" href="index.html">src.optimizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.optimizer.IR_Lv1_Builder.beginWrapper" href="#src.optimizer.IR_Lv1_Builder.beginWrapper">beginWrapper</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.buildBoilerPlate" href="#src.optimizer.IR_Lv1_Builder.buildBoilerPlate">buildBoilerPlate</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.returnLines" href="#src.optimizer.IR_Lv1_Builder.returnLines">returnLines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR">LevelOneIR</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.cleanup" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.cleanup">cleanup</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_folding" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_folding">constant_folding</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_propagation" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.constant_propagation">constant_propagation</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.construct" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.construct">construct</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize">optimize</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs">remove_unused_funcs</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars">remove_unused_vars</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>