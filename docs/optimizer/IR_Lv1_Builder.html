<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.optimizer.IR_Lv1_Builder API documentation</title>
<meta name="description" content="This module serves to construct the first linear intermediate representation in the compiler." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.optimizer.IR_Lv1_Builder</code></h1>
</header>
<section id="section-intro">
<p>This module serves to construct the first linear intermediate representation in the compiler.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module serves to construct the first linear intermediate representation in the compiler.
&#34;&#34;&#34;
import os
import re
import sys
from inspect import getsourcefile
from importlib.machinery import SourceFileLoader

irl = SourceFileLoader(&#34;IRLine&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/IRLine.py&#34;).load_module()
ast = SourceFileLoader(&#34;AST_builder&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/../frontend/AST_builder.py&#34;).load_module()

class LevelOneIR():
    &#34;&#34;&#34;
    Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.
    &#34;&#34;&#34;
    def __init__(self,astHead,symTable):
        &#34;&#34;&#34;
        Args:
            astHead: The root node of the AST
            symTable: The symbol table for the input
        &#34;&#34;&#34;
        self.astHead = astHead
        self.symTable = symTable
        self.IR = []

    def construct(self):
        &#34;&#34;&#34;
        Constructs the linear representation for the object.

        Returns:
            IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
        &#34;&#34;&#34;
        sym = self.symTable
        ntv = self.astHead

        varIndex = 0
        lastVarName = &#34;_&#34; + str(varIndex)
        bodyList = []

        # list of all bodies within functions in our C program
        for x in self.astHead.children:
            if x.name == &#34;func&#34;:
                # Each entry is the &#39;(func_node, body_node)&#39;
                bodyList.append((x,x.children[3]))

        returnDigit = 1234
        labelDigit = returnDigit + 1
        lines = []

        for i in bodyList:

            # Beginning of fuction wrapper
            lines.extend(beginWrapper(i, returnDigit))

            # Body of function
            tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
            lines.extend(tmp_lines)

            # End of function wrapper, add closing bracket
            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

            # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
            returnDigit = labelDigit

            self.IR = lines

        return self.IR

    def __str__(self):            
        return &#34;\n&#34;.join([str(x) for x in self.IR]) + &#34;\n&#34;

    def optimize(self): 
        self.remove_unused_funcs()
        self.remove_unused_vars()

    def remove_unused_vars(self):
        ir = self.IR
        scope = &#34;&#34;
        
        #get variables to remove
        vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
        #get function from symbol table.
        funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

        final_ir = []
        
        for irLine in ir:

            for idx, irNode in enumerate(irLine.treeList):
                #check if function declaration, to set new scope
                if isinstance(irNode, irl.IRFunctionDecl):
                    scope = irNode.name

                #check if declaration
                if isinstance(irNode, irl.IRVariableInit):
                    #check if variable needs to be skippped
                    if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                        del irLine.treeList[idx]
            
                #check if usage
                elif(isinstance(irNode, irl.IRAssignment)):
                    if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                        del irLine.treeList[idx]

            #irLine has no irNode inside...so we dont add it to new IR list
            if irLine.treeList == []:
                pass
            else:
                final_ir.append(irLine)
            
            
        self.IR = final_ir

    def remove_unused_funcs(self):
        ir = self.IR        
        inFunction = False
        to_remove = []

        for idx, irLine in enumerate(ir):

            # Only need to focus on first Node in each IRLine
            ir_firstNode = irLine.treeList[0]

            # Delete IRLine if we are in a &#39;unused&#39; function
            # Mark &#39;inFunction&#39; to False if beginning of new function
            if inFunction == True:
                if isinstance(ir_firstNode, irl.IRFunctionDecl):
                    inFunction = False
                else:    
                    to_remove.append(idx)
                    continue

            # Check for function
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                func_name = ir_firstNode.name
                referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])
                
                # If reference is 0, it is unused 
                if referenceNum == 0 and func_name != &#34;main&#34;:
                    to_remove.append(idx)
                    inFunction = True

        # Actually delete unused function IRLine&#39;s
        for i in to_remove[::-1]:
            del ir[i]
                

        self.IR = ir

def buildBoilerPlate(symTable):
    namesandparams = []
    functionNames = [(x.name,x.type) for x in symTable.symbols if x.is_function]
    params = [(x.name,x.scope,x.type) for x in symTable.symbols if x.is_param]

    for x in functionNames:
        track = 0
        paramsLi = []
        for i in params:
            if x[0] == i[1].split(&#34;/&#34;)[1]:
                track+=1

                paramsLi.append((i[2],i[0]))
        if track == 0:
            namesandparams.append((x[0],paramsLi,x[1]))
        else:
            namesandparams.append((x[0],paramsLi,x[1]))
    return namesandparams

def beginWrapper(function_tuple, returnDigit):
    &#34;&#34;&#34;
    Produces the function wrappers and initializes the return digit for the given function.

    Returns:
        lines: The lines of the start of the function
    &#34;&#34;&#34;
    lines = []
    params = &#34;&#34;
    func_type = function_tuple[0].children[0].name
    func_name = function_tuple[0].children[1].name

    for var in function_tuple[0].children[2].children:
        if var.name == &#34;var&#34;:
            params += f&#34;{var.children[0].name} {var.children[1].name},&#34;

    lines.append(irl.IRLine.singleEntry(irl.IRFunctionDecl(func_name, params[:-1])))
    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True)))
    
    if func_type != &#34;void&#34;:
        modifiers = f&#34;{&#39;&#39;.join([x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]])}{&#39; &#39; if [x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]] else &#39;&#39;}&#34;
        lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, func_type, f&#34;D.{returnDigit}&#34;)))
    
    return lines

def returnLines(node,returnDigit,labelDigit,successDigit=None,failureDigit=None):
    &#34;&#34;&#34;
    Produces a linear representation of the content nested within `node`.

    Args:
        node: The AST node.
        returnDigit: The variable to store the return value.
        labelDigit: A list of all previously used label values.
        successDigit: The label value to jump to if there is a `continue`.
        failureDigit: The label value to jump to if there is a `break`.
        prefix: The string prefix for indenting the given line.

    Returns:
        lines: The lines produced from the content.
        labelDigit: The list of all used label values.
    &#34;&#34;&#34;
    lines = []
    if node.name == &#34;body&#34;:
        il = [x.children[0] for x in node.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]

        # It is the scopes responsibility to ensure that the content is wrapped in braces
        if il:
            for x in il:
                modifiers = f&#34;{&#39; &#39;.join([y.name for y in x.children[0].children])}{&#39; &#39; if [y.name for y in x.children[0].children] else &#39;&#39;}&#34;
                lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, x.children[0].name, x.children[1].name), [labelDigit]))
    
    for element in node.children:
        try:
            splits = [[&#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;, &#34;=&#34;],[&#34;for&#34;],[&#34;body&#34;],[&#34;branch&#34;],[&#34;return&#34;],[&#34;call&#34;],[&#34;while&#34;, &#34;do_while&#34;],[&#34;break&#34;],[&#34;continue&#34;],[&#34;goto&#34;],[&#34;label&#34;], [&#34;++&#34;, &#34;--&#34;]]
            ind = [splits.index(x) for x in splits if element.name in x]
            ind = ind[0]
            if ind == 0:
                line = irl.IRLine(element, tvs=[], labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                if labelList != []:
                    labelDigit = labelList[-1]

            elif ind == 1:
                # For Loop
                ns = False
                # Initialize variable
                if element.children[0].children != []:
                    initNode = ast.ASTNode(&#34;body&#34;, None)
                    initNode.children.append(element.children[0])
                    if [x.children[0] for x in initNode.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Keep track of label for conditional block (if conditional exist)
                conditionLabel = None
                if element.children[1].children != []:

                    # Append an IRGoTo node
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    conditionLabel = labelDigit
                    labelDigit += 1

                # Append an IRJump node for the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[3], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                # Add the &#34;end-of-loop&#34; assignment/arithmetic
                if element.children[2].children != []:
                    initNode = ast.ASTNode(&#34;tmp&#34;, None)
                    initNode.children.append(element.children[2])
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Start of conditionals for the loop
                if conditionLabel != None:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                    tmpNode = element.children[1]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[1])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1]

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                else:
                    # No conditional (jump to start of body...always True)
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{loopStart}&gt;&#34;), [labelDigit]))

                # increment twice for new index
                labelDigit += 2

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 2:
                # Append an IRBracket node 
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))

                tmp, labelDigit = returnLines(element, returnDigit, labelDigit, successDigit, failureDigit)
                lines.extend(tmp)

                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 3:
                # If/Else statement(s)

                # list of goto labels to be appended at end of if blocks
                end_if = []

                #for each case in a branch
                for case in element.children:
                    ns = False
                    #create label for body if true and label to skip to correct place if false.
                    success_label = labelDigit
                    labelDigit += 1
                    failure_label = labelDigit
                    labelDigit += 1

                    #default is an &#39;else&#39;. Only has one child, body
                    if case.name == &#34;default&#34;:
                        if [x.children[0] for x in case.children[0].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                            ns = True

                        #Get lines for the body and assign new labeldigit
                        tmp, labelDigit = returnLines(case.children[0], returnDigit, labelDigit, success_label, failure_label)
                        lines.extend(tmp)

                        if ns:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))
                        
                        break

                    tmpNode = case.children[0]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(case.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    #break down argument for if statement into smaller if statements
                    line = irl.IRLine(tmpNode, tvs=[], success=success_label, failure=failure_label, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1


                    #Add goto for body statement
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{success_label}&gt;&#34;), [labelDigit]))
                    
                    if [x.children[0] for x in case.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    
                    #Get lines for the if body and assign new labeldigit
                    tmp, labelDigit = returnLines(case.children[1], returnDigit,  labelDigit, success_label, failure_label)
                    lines.extend(tmp)

                    if ns:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                    #append goto for end of if body
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    end_if.append(labelDigit)
                    labelDigit += 1

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{failure_label}&gt;&#34;), [labelDigit]))

                for i in end_if:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{i}&gt;&#34;), [labelDigit]))
                    
            elif ind == 4:
                #Return

                # If returns some type of arithmetic expression, breaks it down.
                if len(element.children) &gt; 0 and element.children[0].children != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    if line.treeList != []:
                        lines.append(line)

                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                    if labelList != []:
                        labelDigit = labelList[-1]

                elif len(element.children) &gt; 0 and element.children[0].children == []:
                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{element.children[0].name}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                # Returns nothing
                else:             
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(None), [labelDigit]))

            elif ind == 5:
                #Function Call
                func_call = element.children[0].name

                # function call has parameters
                if element.children[0] != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1

                # no parameters
                else:
                    # Append Empty function call node             
                    lines.append(irl.IRLine.singleEntry(irl.IRFunctionCall(func_call, None), [labelDigit]))

            elif ind == 6:
                #While and Do While

                ns = False

                # Jump straight to conditionals for only &#39;While&#39; statements
                if element.name == &#34;while&#34;:
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Keep track of label for conditional block
                conditionLabel = labelDigit
                labelDigit += 1

                # Add the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                if [x.children[0] for x in element.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[1], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                # Start of conditionals for the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                tmpNode = element.children[0]
                if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                if labelList != []:
                    labelDigit = labelList[-1]
                # increment twice for new index (twce, in case it was a do while)
                labelDigit += 2

            elif ind == 7:
                # Break
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{failureDigit}&gt;&#34;), [labelDigit]))

            elif ind == 8:
                # Continue
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{successDigit}&gt;&#34;), [labelDigit]))

            elif ind == 9:
                # Goto
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;{element.children[0].name}&#34;), [labelDigit]))
            elif ind == 10:
                # Jump Label
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;{element.children[0].name}&#34;), [labelDigit]))
                
                if (len(element.children) &gt; 1):
                    temp_lines, labelDigit = returnLines(element.children[1], returnDigit, labelDigit)
                    lines.extend(temp_lines)

            elif ind == 11:
                # Special assignment? (++, --)
                line = irl.IRLine(element, tvs=[])
                tvs, labelList = line.retrieve()
                lines.append(line)

            else:
                print(&#34;Unsupported at this time&#34;)

        except Warning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            print(exc_type, exc_tb.tb_lineno)
            pass

    return lines, labelDigit</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.beginWrapper"><code class="name flex">
<span>def <span class="ident">beginWrapper</span></span>(<span>function_tuple, returnDigit)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces the function wrappers and initializes the return digit for the given function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lines</code></strong></dt>
<dd>The lines of the start of the function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beginWrapper(function_tuple, returnDigit):
    &#34;&#34;&#34;
    Produces the function wrappers and initializes the return digit for the given function.

    Returns:
        lines: The lines of the start of the function
    &#34;&#34;&#34;
    lines = []
    params = &#34;&#34;
    func_type = function_tuple[0].children[0].name
    func_name = function_tuple[0].children[1].name

    for var in function_tuple[0].children[2].children:
        if var.name == &#34;var&#34;:
            params += f&#34;{var.children[0].name} {var.children[1].name},&#34;

    lines.append(irl.IRLine.singleEntry(irl.IRFunctionDecl(func_name, params[:-1])))
    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True)))
    
    if func_type != &#34;void&#34;:
        modifiers = f&#34;{&#39;&#39;.join([x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]])}{&#39; &#39; if [x.name for x in function_tuple[0].children[0].children if x.name in [&#39;signed&#39;, &#39;unsigned&#39;]] else &#39;&#39;}&#34;
        lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, func_type, f&#34;D.{returnDigit}&#34;)))
    
    return lines</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.buildBoilerPlate"><code class="name flex">
<span>def <span class="ident">buildBoilerPlate</span></span>(<span>symTable)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildBoilerPlate(symTable):
    namesandparams = []
    functionNames = [(x.name,x.type) for x in symTable.symbols if x.is_function]
    params = [(x.name,x.scope,x.type) for x in symTable.symbols if x.is_param]

    for x in functionNames:
        track = 0
        paramsLi = []
        for i in params:
            if x[0] == i[1].split(&#34;/&#34;)[1]:
                track+=1

                paramsLi.append((i[2],i[0]))
        if track == 0:
            namesandparams.append((x[0],paramsLi,x[1]))
        else:
            namesandparams.append((x[0],paramsLi,x[1]))
    return namesandparams</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.returnLines"><code class="name flex">
<span>def <span class="ident">returnLines</span></span>(<span>node, returnDigit, labelDigit, successDigit=None, failureDigit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces a linear representation of the content nested within <code>node</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node.</dd>
<dt><strong><code>returnDigit</code></strong></dt>
<dd>The variable to store the return value.</dd>
<dt><strong><code>labelDigit</code></strong></dt>
<dd>A list of all previously used label values.</dd>
<dt><strong><code>successDigit</code></strong></dt>
<dd>The label value to jump to if there is a <code>continue</code>.</dd>
<dt><strong><code>failureDigit</code></strong></dt>
<dd>The label value to jump to if there is a <code>break</code>.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The string prefix for indenting the given line.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lines</code></strong></dt>
<dd>The lines produced from the content.</dd>
<dt><strong><code>labelDigit</code></strong></dt>
<dd>The list of all used label values.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returnLines(node,returnDigit,labelDigit,successDigit=None,failureDigit=None):
    &#34;&#34;&#34;
    Produces a linear representation of the content nested within `node`.

    Args:
        node: The AST node.
        returnDigit: The variable to store the return value.
        labelDigit: A list of all previously used label values.
        successDigit: The label value to jump to if there is a `continue`.
        failureDigit: The label value to jump to if there is a `break`.
        prefix: The string prefix for indenting the given line.

    Returns:
        lines: The lines produced from the content.
        labelDigit: The list of all used label values.
    &#34;&#34;&#34;
    lines = []
    if node.name == &#34;body&#34;:
        il = [x.children[0] for x in node.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]

        # It is the scopes responsibility to ensure that the content is wrapped in braces
        if il:
            for x in il:
                modifiers = f&#34;{&#39; &#39;.join([y.name for y in x.children[0].children])}{&#39; &#39; if [y.name for y in x.children[0].children] else &#39;&#39;}&#34;
                lines.append(irl.IRLine.singleEntry(irl.IRVariableInit(modifiers, x.children[0].name, x.children[1].name), [labelDigit]))
    
    for element in node.children:
        try:
            splits = [[&#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;, &#34;=&#34;],[&#34;for&#34;],[&#34;body&#34;],[&#34;branch&#34;],[&#34;return&#34;],[&#34;call&#34;],[&#34;while&#34;, &#34;do_while&#34;],[&#34;break&#34;],[&#34;continue&#34;],[&#34;goto&#34;],[&#34;label&#34;], [&#34;++&#34;, &#34;--&#34;]]
            ind = [splits.index(x) for x in splits if element.name in x]
            ind = ind[0]
            if ind == 0:
                line = irl.IRLine(element, tvs=[], labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                if labelList != []:
                    labelDigit = labelList[-1]

            elif ind == 1:
                # For Loop
                ns = False
                # Initialize variable
                if element.children[0].children != []:
                    initNode = ast.ASTNode(&#34;body&#34;, None)
                    initNode.children.append(element.children[0])
                    if [x.children[0] for x in initNode.children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Keep track of label for conditional block (if conditional exist)
                conditionLabel = None
                if element.children[1].children != []:

                    # Append an IRGoTo node
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    conditionLabel = labelDigit
                    labelDigit += 1

                # Append an IRJump node for the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[3], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                # Add the &#34;end-of-loop&#34; assignment/arithmetic
                if element.children[2].children != []:
                    initNode = ast.ASTNode(&#34;tmp&#34;, None)
                    initNode.children.append(element.children[2])
                    tmp, labelDigit = returnLines(initNode, returnDigit, labelDigit)
                    lines.extend(tmp)

                # Start of conditionals for the loop
                if conditionLabel != None:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                    tmpNode = element.children[1]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[1])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1]

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                else:
                    # No conditional (jump to start of body...always True)
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{loopStart}&gt;&#34;), [labelDigit]))

                # increment twice for new index
                labelDigit += 2

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 2:
                # Append an IRBracket node 
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))

                tmp, labelDigit = returnLines(element, returnDigit, labelDigit, successDigit, failureDigit)
                lines.extend(tmp)

                # Append an IRBracket node
                lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

            elif ind == 3:
                # If/Else statement(s)

                # list of goto labels to be appended at end of if blocks
                end_if = []

                #for each case in a branch
                for case in element.children:
                    ns = False
                    #create label for body if true and label to skip to correct place if false.
                    success_label = labelDigit
                    labelDigit += 1
                    failure_label = labelDigit
                    labelDigit += 1

                    #default is an &#39;else&#39;. Only has one child, body
                    if case.name == &#34;default&#34;:
                        if [x.children[0] for x in case.children[0].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                            ns = True

                        #Get lines for the body and assign new labeldigit
                        tmp, labelDigit = returnLines(case.children[0], returnDigit, labelDigit, success_label, failure_label)
                        lines.extend(tmp)

                        if ns:
                            # Append an IRBracket node
                            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))
                        
                        break

                    tmpNode = case.children[0]
                    if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(case.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                    #break down argument for if statement into smaller if statements
                    line = irl.IRLine(tmpNode, tvs=[], success=success_label, failure=failure_label, labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1


                    #Add goto for body statement
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{success_label}&gt;&#34;), [labelDigit]))
                    
                    if [x.children[0] for x in case.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True
                    
                    #Get lines for the if body and assign new labeldigit
                    tmp, labelDigit = returnLines(case.children[1], returnDigit,  labelDigit, success_label, failure_label)
                    lines.extend(tmp)

                    if ns:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                    #append goto for end of if body
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                    end_if.append(labelDigit)
                    labelDigit += 1

                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{failure_label}&gt;&#34;), [labelDigit]))

                for i in end_if:
                    lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{i}&gt;&#34;), [labelDigit]))
                    
            elif ind == 4:
                #Return

                # If returns some type of arithmetic expression, breaks it down.
                if len(element.children) &gt; 0 and element.children[0].children != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    if line.treeList != []:
                        lines.append(line)

                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{tvs[-1]}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                    if labelList != []:
                        labelDigit = labelList[-1]

                elif len(element.children) &gt; 0 and element.children[0].children == []:
                    lines.append(irl.IRLine.singleEntry(irl.IRAssignment(f&#34;D.{returnDigit}&#34;, f&#34;{element.children[0].name}&#34;), [labelDigit]))
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(f&#34;D.{returnDigit}&#34;), [labelDigit]))

                # Returns nothing
                else:             
                    lines.append(irl.IRLine.singleEntry(irl.IRReturn(None), [labelDigit]))

            elif ind == 5:
                #Function Call
                func_call = element.children[0].name

                # function call has parameters
                if element.children[0] != []:
                    line = irl.IRLine(element.children[0], tvs=[], labelList=[labelDigit])
                    tvs, labelList = line.retrieve()
                    lines.append(line)

                    if labelList != []:
                        labelDigit = labelList[-1] + 1

                # no parameters
                else:
                    # Append Empty function call node             
                    lines.append(irl.IRLine.singleEntry(irl.IRFunctionCall(func_call, None), [labelDigit]))

            elif ind == 6:
                #While and Do While

                ns = False

                # Jump straight to conditionals for only &#39;While&#39; statements
                if element.name == &#34;while&#34;:
                    lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                # Keep track of label for conditional block
                conditionLabel = labelDigit
                labelDigit += 1

                # Add the label that belongs to the start of the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{labelDigit}&gt;&#34;), [labelDigit]))

                if [x.children[0] for x in element.children[1].children if x.name == &#34;=&#34; and x.children[0].children[0].name in [&#34;auto&#34;, &#34;long double&#34;, &#34;double&#34;, &#34;float&#34;, &#34;long long&#34;, &#34;long long int&#34;, &#34;long&#34;, &#34;int&#34;, &#34;short&#34;, &#34;char&#34;]]:
                        # Append an IRBracket node
                        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=True), [labelDigit]))
                        ns = True

                # Assign labels for start/end of loop
                loopStart = labelDigit
                loopEnd = labelDigit + 1
                labelDigit += 2

                # recursivly deal with the body of the loop
                tmp, labelDigit = returnLines(element.children[1], returnDigit, labelDigit, loopStart, loopEnd)
                lines.extend(tmp)

                if ns:
                    # Append an IRBracket node
                    lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False), [labelDigit]))

                # Start of conditionals for the loop
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{conditionLabel}&gt;&#34;), [labelDigit]))

                tmpNode = element.children[0]
                if tmpNode.name not in [&#39;||&#39;, &#39;&amp;&amp;&#39;, &#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]:
                        tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                        tmpNode.children.append(element.children[0])
                        tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

                line = irl.IRLine(tmpNode, tvs=[], success=loopStart, failure=loopEnd, labelList=[labelDigit])
                tvs, labelList = line.retrieve()
                lines.append(line)

                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;&lt;D.{loopEnd}&gt;&#34;), [labelDigit]))

                if labelList != []:
                    labelDigit = labelList[-1]
                # increment twice for new index (twce, in case it was a do while)
                labelDigit += 2

            elif ind == 7:
                # Break
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{failureDigit}&gt;&#34;), [labelDigit]))

            elif ind == 8:
                # Continue
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;&lt;D.{successDigit}&gt;&#34;), [labelDigit]))

            elif ind == 9:
                # Goto
                lines.append(irl.IRLine.singleEntry(irl.IRGoTo(f&#34;{element.children[0].name}&#34;), [labelDigit]))
            elif ind == 10:
                # Jump Label
                lines.append(irl.IRLine.singleEntry(irl.IRJump(f&#34;{element.children[0].name}&#34;), [labelDigit]))
                
                if (len(element.children) &gt; 1):
                    temp_lines, labelDigit = returnLines(element.children[1], returnDigit, labelDigit)
                    lines.extend(temp_lines)

            elif ind == 11:
                # Special assignment? (++, --)
                line = irl.IRLine(element, tvs=[])
                tvs, labelList = line.retrieve()
                lines.append(line)

            else:
                print(&#34;Unsupported at this time&#34;)

        except Warning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            print(exc_type, exc_tb.tb_lineno)
            pass

    return lines, labelDigit</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR"><code class="flex name class">
<span>class <span class="ident">LevelOneIR</span></span>
<span>(</span><span>astHead, symTable)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>astHead</code></strong></dt>
<dd>The root node of the AST</dd>
<dt><strong><code>symTable</code></strong></dt>
<dd>The symbol table for the input</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LevelOneIR():
    &#34;&#34;&#34;
    Constructs the linear representation of the input program in order to allow for optimizations such as constant folding, constant proagation, as well as removal of unused variables and functions depending on the optimization level provided as a commandline argument.
    &#34;&#34;&#34;
    def __init__(self,astHead,symTable):
        &#34;&#34;&#34;
        Args:
            astHead: The root node of the AST
            symTable: The symbol table for the input
        &#34;&#34;&#34;
        self.astHead = astHead
        self.symTable = symTable
        self.IR = []

    def construct(self):
        &#34;&#34;&#34;
        Constructs the linear representation for the object.

        Returns:
            IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
        &#34;&#34;&#34;
        sym = self.symTable
        ntv = self.astHead

        varIndex = 0
        lastVarName = &#34;_&#34; + str(varIndex)
        bodyList = []

        # list of all bodies within functions in our C program
        for x in self.astHead.children:
            if x.name == &#34;func&#34;:
                # Each entry is the &#39;(func_node, body_node)&#39;
                bodyList.append((x,x.children[3]))

        returnDigit = 1234
        labelDigit = returnDigit + 1
        lines = []

        for i in bodyList:

            # Beginning of fuction wrapper
            lines.extend(beginWrapper(i, returnDigit))

            # Body of function
            tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
            lines.extend(tmp_lines)

            # End of function wrapper, add closing bracket
            lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

            # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
            returnDigit = labelDigit

            self.IR = lines

        return self.IR

    def __str__(self):            
        return &#34;\n&#34;.join([str(x) for x in self.IR]) + &#34;\n&#34;

    def optimize(self): 
        self.remove_unused_funcs()
        self.remove_unused_vars()

    def remove_unused_vars(self):
        ir = self.IR
        scope = &#34;&#34;
        
        #get variables to remove
        vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
        #get function from symbol table.
        funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

        final_ir = []
        
        for irLine in ir:

            for idx, irNode in enumerate(irLine.treeList):
                #check if function declaration, to set new scope
                if isinstance(irNode, irl.IRFunctionDecl):
                    scope = irNode.name

                #check if declaration
                if isinstance(irNode, irl.IRVariableInit):
                    #check if variable needs to be skippped
                    if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                        del irLine.treeList[idx]
            
                #check if usage
                elif(isinstance(irNode, irl.IRAssignment)):
                    if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                        del irLine.treeList[idx]

            #irLine has no irNode inside...so we dont add it to new IR list
            if irLine.treeList == []:
                pass
            else:
                final_ir.append(irLine)
            
            
        self.IR = final_ir

    def remove_unused_funcs(self):
        ir = self.IR        
        inFunction = False
        to_remove = []

        for idx, irLine in enumerate(ir):

            # Only need to focus on first Node in each IRLine
            ir_firstNode = irLine.treeList[0]

            # Delete IRLine if we are in a &#39;unused&#39; function
            # Mark &#39;inFunction&#39; to False if beginning of new function
            if inFunction == True:
                if isinstance(ir_firstNode, irl.IRFunctionDecl):
                    inFunction = False
                else:    
                    to_remove.append(idx)
                    continue

            # Check for function
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                func_name = ir_firstNode.name
                referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])
                
                # If reference is 0, it is unused 
                if referenceNum == 0 and func_name != &#34;main&#34;:
                    to_remove.append(idx)
                    inFunction = True

        # Actually delete unused function IRLine&#39;s
        for i in to_remove[::-1]:
            del ir[i]
                

        self.IR = ir</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.construct"><code class="name flex">
<span>def <span class="ident">construct</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs the linear representation for the object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>IR</code></strong></dt>
<dd>A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct(self):
    &#34;&#34;&#34;
    Constructs the linear representation for the object.

    Returns:
        IR: A collection of strings and IRLine objects which can be optimized and/or transformed into assembly.
    &#34;&#34;&#34;
    sym = self.symTable
    ntv = self.astHead

    varIndex = 0
    lastVarName = &#34;_&#34; + str(varIndex)
    bodyList = []

    # list of all bodies within functions in our C program
    for x in self.astHead.children:
        if x.name == &#34;func&#34;:
            # Each entry is the &#39;(func_node, body_node)&#39;
            bodyList.append((x,x.children[3]))

    returnDigit = 1234
    labelDigit = returnDigit + 1
    lines = []

    for i in bodyList:

        # Beginning of fuction wrapper
        lines.extend(beginWrapper(i, returnDigit))

        # Body of function
        tmp_lines , labelDigit = returnLines(i[1], returnDigit, labelDigit)
        lines.extend(tmp_lines)

        # End of function wrapper, add closing bracket
        lines.append(irl.IRLine.singleEntry(irl.IRBracket(opening=False)))

        # NOTE: &#39;labelDigit&#39; should be the newest and unused digit
        returnDigit = labelDigit

        self.IR = lines

    return self.IR</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(self): 
    self.remove_unused_funcs()
    self.remove_unused_vars()</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs"><code class="name flex">
<span>def <span class="ident">remove_unused_funcs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unused_funcs(self):
    ir = self.IR        
    inFunction = False
    to_remove = []

    for idx, irLine in enumerate(ir):

        # Only need to focus on first Node in each IRLine
        ir_firstNode = irLine.treeList[0]

        # Delete IRLine if we are in a &#39;unused&#39; function
        # Mark &#39;inFunction&#39; to False if beginning of new function
        if inFunction == True:
            if isinstance(ir_firstNode, irl.IRFunctionDecl):
                inFunction = False
            else:    
                to_remove.append(idx)
                continue

        # Check for function
        if isinstance(ir_firstNode, irl.IRFunctionDecl):
            func_name = ir_firstNode.name
            referenceNum = len([x.references for x in self.symTable.symbols if func_name == x.name and x.entry_type == 1][0])
            
            # If reference is 0, it is unused 
            if referenceNum == 0 and func_name != &#34;main&#34;:
                to_remove.append(idx)
                inFunction = True

    # Actually delete unused function IRLine&#39;s
    for i in to_remove[::-1]:
        del ir[i]
            

    self.IR = ir</code></pre>
</details>
</dd>
<dt id="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars"><code class="name flex">
<span>def <span class="ident">remove_unused_vars</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unused_vars(self):
    ir = self.IR
    scope = &#34;&#34;
    
    #get variables to remove
    vars_temp = [[x.name, x.scope] for x in self.symTable.symbols if x.entry_type != 2 and x.entry_type != 1 and x.entry_type != 3 and len(x.references) == 0]
    #get function from symbol table.
    funcs = [x.name for x in self.symTable.symbols if x.entry_type == 1]

    final_ir = []
    
    for irLine in ir:

        for idx, irNode in enumerate(irLine.treeList):
            #check if function declaration, to set new scope
            if isinstance(irNode, irl.IRFunctionDecl):
                scope = irNode.name

            #check if declaration
            if isinstance(irNode, irl.IRVariableInit):
                #check if variable needs to be skippped
                if [x for x in vars_temp if x[0] == irNode.var and scope in x[1]] != []:
                    del irLine.treeList[idx]
        
            #check if usage
            elif(isinstance(irNode, irl.IRAssignment)):
                if [x for x in vars_temp if x[0] == irNode.lhs and scope in x[1]] != []:
                    del irLine.treeList[idx]

        #irLine has no irNode inside...so we dont add it to new IR list
        if irLine.treeList == []:
            pass
        else:
            final_ir.append(irLine)
        
        
    self.IR = final_ir</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.optimizer" href="index.html">src.optimizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.optimizer.IR_Lv1_Builder.beginWrapper" href="#src.optimizer.IR_Lv1_Builder.beginWrapper">beginWrapper</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.buildBoilerPlate" href="#src.optimizer.IR_Lv1_Builder.buildBoilerPlate">buildBoilerPlate</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.returnLines" href="#src.optimizer.IR_Lv1_Builder.returnLines">returnLines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR">LevelOneIR</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.construct" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.construct">construct</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.optimize">optimize</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_funcs">remove_unused_funcs</a></code></li>
<li><code><a title="src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars" href="#src.optimizer.IR_Lv1_Builder.LevelOneIR.remove_unused_vars">remove_unused_vars</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>