<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.optimizer.IRLine API documentation</title>
<meta name="description" content="This module abstracts the necessary lines for the linear IR to allow for easier optimization methods like constant propagation, constant folding, â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.optimizer.IRLine</code></h1>
</header>
<section id="section-intro">
<p>This module abstracts the necessary lines for the linear IR to allow for easier optimization methods like constant propagation, constant folding, unused references ect.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module abstracts the necessary lines for the linear IR to allow for easier optimization methods like constant propagation, constant folding, unused references ect.
&#34;&#34;&#34;
import importlib
import os
from inspect import getsourcefile
from importlib.machinery import SourceFileLoader

ast = SourceFileLoader(&#34;AST_builder&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/../frontend/AST_builder.py&#34;).load_module()
asmn = SourceFileLoader(&#34;ASMNode&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/../backend/ASMNode.py&#34;).load_module()
stk = SourceFileLoader(&#34;stack&#34;, f&#34;{os.path.dirname(os.path.abspath(getsourcefile(lambda:0)))}/../backend/stack.py&#34;).load_module()

global tmpVarIndex
tmpVarIndex = 0

class IRLine():
    &#34;&#34;&#34;
    A class that contains all the intermediate representations for a given AST node. Will produce a linear representation when converted to a string
    &#34;&#34;&#34;
    def __init__(self, node, tvs = [], success = None, failure = None, labelList = [], prefix = &#34;&#34;):
        &#34;&#34;&#34;
        Args:
            node: The AST node corresponding to the collection of lines
            tvs: The current tempoary variable storage
            success: The success label
            failure: The failure label
            labelList: The list of used label names
            prefix: The output prefix
        &#34;&#34;&#34;

        self.astNode = node
        self.treeList = []

        self.tvs = tvs
        self.labelList = labelList
        self.prefix = prefix

        self.log_ops = [&#39;||&#39;, &#39;&amp;&amp;&#39;]
        self.comp_ops = [&#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]
        self.arth_ops = [&#34;+&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;%&#34;, &#34;&lt;&lt;&#34;, &#34;&gt;&gt;&#34;, &#34;|&#34;, &#34;&amp;&#34;, &#34;^&#34;, &#34;!&#34;, &#34;~&#34;]
        self.spec_ops = [&#34;++&#34;, &#34;--&#34;]
        self.ass_ops = [&#34;=&#34;, &#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;]
        self.id_ops = [&#34;var&#34;, &#34;call&#34;]

        # Based on the node construct the needed intermediate trees in order
        if node == None:
            # There was no AST node passed in. This is the case when there
            # are no complex IR instructions that need to be broken down.
            # IRNode will be added manually to self.treeList.
            pass

        elif node.name in self.log_ops:
            self.boolean_breakdown(self.astNode, success, failure)
        else:
            self.expression_breakdown(self.astNode, success, failure)


    def retrieve(self):
        &#34;&#34;&#34;
        Retrieves the updated tempoary variable storage and list of unavailable label names for the future.

        Returns:
            tvs: The current tempoary variable storage
            labelList: The list of used label names
        &#34;&#34;&#34;
        return self.tvs, self.labelList

    def expression_breakdown(self, root, success, failure):
        &#34;&#34;&#34;
        Breaks down smaller expressions in order to evaluate them

        Args:
            root: The root AST node
            success: The success label
            failure: The failure label
        &#34;&#34;&#34;
        if success not in self.labelList and success != None:
            self.labelList.append(success)
        if failure not in self.labelList and failure != None:
            self.labelList.append(failure)

        ns = root.list_POT()
        global tmpVarIndex
        ns = [x for x in ns if x.name in self.arth_ops or x.name in self.spec_ops or x.name in self.ass_ops or x.name in self.id_ops or x.name in self.comp_ops]
        for node in ns:
            if node.name in self.comp_ops:

                if node.name in self.comp_ops and node.parent != None and node.parent.name == &#34;!&#34;:
                    # logical not means we need to reverse this comparison
                    if node.name == &#34;&gt;&#34;: node.name = &#34;&lt;=&#34;
                    elif node.name == &#34;&lt;&#34;: node.name = &#34;&gt;=&#34;
                    elif node.name == &#34;==&#34;: node.name = &#34;!=&#34;
                    elif node.name == &#34;!=&#34;: node.name = &#34;==&#34;
                    elif node.name == &#34;&gt;=&#34;: node.name = &#34;&lt;&#34;
                    elif node.name == &#34;&lt;=&#34;: node.name = &#34;&gt;&#34;

                self.treeList.append(
                    IRIf(
                        node,
                        success,
                        failure,
                        [self.tvs.pop() for x in node.children if len(x.children) != 0]
                    )
                )

            elif node.name in self.arth_ops:
                tmpVarIndex += 1
                self.treeList.append(
                    IRArth(
                        node,
                        [self.tvs.pop() for x in node.children if len(x.children) != 0],
                        f&#34;tV_{tmpVarIndex}&#34;
                    )
                )

                self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

            elif node.name in self.spec_ops:
                var = self.tvs.pop()

                tmpVarIndex += 1

                # Create a temporay AST to deal with storing of the current value of the variable
                # tmpNode = ast.ASTNode(&#34;=&#34;, None)
                # tmpNode.children.append(ast.ASTNode(f&#34;_{tmpVarIndex}&#34;, tmpNode))
                # tmpNode.children.append(ast.ASTNode(var, tmpNode))

                self.treeList.append(
                    IRAssignment(
                        f&#34;tV_{tmpVarIndex}&#34;,
                        var
                    )
                )
                if [node.children.index(x) for x in node.children if x.name == &#34;NULL&#34;][0] == 1:
                    self.treeList.append(
                        IRSpecial(
                            node,
                            var
                        )
                    )
                else:
                    self.treeList.insert(len(self.treeList) - 2,
                        IRSpecial(
                            node,
                            var
                        )
                    )

                self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

            elif node.name in self.ass_ops:
                if self.ass_ops.index(node.name) == 0:
                    lhs = None
                    rhs = None
                    # Case 1: Assignment is constant. ie. int i = 0
                    if len(node.children[1].children) == 0:
                        lhs = self.tvs.pop()
                        rhs = f&#34;{node.children[1].name}&#34;
                    # Case 2: Assignment is complex
                    else:
                        lhs = f&#34;rV_{node.children[0].children[len(node.children[0].children)-1].name}&#34;
                        rhs = self.tvs.pop()

                    self.treeList.append(
                            IRAssignment(
                                lhs,
                                rhs
                            )
                        )
                else:
                    # create a temporary parent node
                    p = ast.ASTNode(&#34;=&#34;, None)

                    # append the variable who is assigned a value as its first child
                    p.children.append(node.children[0])

                    # create a right subtree with the correct operation
                    r = ast.ASTNode(node.name[:-1], p)
                    p.children.append(r)

                    rc = None
                    lc = None

                    # assign the variable as the left operand of the new expression
                    if len(node.children[1].children) &gt; 0:
                        rc = ast.ASTNode(self.tvs.pop(), r)
                    else:
                        rc = node.children[1]

                    # assign the variable as the left operand of the new expression
                    if len(node.children[0].children) &gt; 0:
                        lc = ast.ASTNode(self.tvs.pop(), r)
                    else:
                        lc = node.children[0]

                    # assign the remaining operations as the right operand of the new expression

                    r.children.append(lc)
                    r.children.append(rc)

                    self.expression_breakdown(p, success, failure)

            elif node.name in self.id_ops:
                if node.name == &#34;var&#34;:
                    self.tvs.append(f&#34;rV_{node.children[len(node.children)-1].name}&#34;)
                elif node.name == &#34;call&#34;:
                    # list of indices that correspond to the complex parameters of the function call
                    complexP = [node.children[0].children.index(x) for x in node.children[0].children if len(x.children) &gt; 0]
                    simpleP = [x for x in range(len(node.children[0].children)) if x not in complexP]

                    params = [self.tvs.pop() for x in range(len(node.children[0].children)) if x in complexP]

                    tmpVarIndex += 1
                    self.treeList.append(
                        IRFunctionAssign(
                            node,
                            [params.pop() if x in complexP else node.children[0].children[x].name for x in range(len(node.children[0].children))],
                            f&#34;tV_{tmpVarIndex}&#34;
                        )
                    )

                    self.tvs.append(self.treeList[-1].lhs)

    def boolean_breakdown(self, root, success, failure):
        &#34;&#34;&#34;
        Breaks down larger boolean expressions in order to evaluate them

        Args:
            root: The root AST node
            success: The success label
            failure: The failure label
        &#34;&#34;&#34;
        if success not in self.labelList and success != None:
            self.labelList.append(success)
        if failure not in self.labelList and failure != None:
            self.labelList.append(failure)

        index = self.log_ops.index(root.name)
        if index == 0:
            # OR
            tmp_label = max(self.labelList)
            self.labelList.append(tmp_label+1)
            tmpNode = root.children[0]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[0])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, tmp_label)
            else:
                self.expression_breakdown(tmpNode, success, tmp_label)

            self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

            tmpNode = root.children[1]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops and (
                tmpNode.children == [] or
                tmpNode.children[0].name not in self.comp_ops and tmpNode.children[0].name not in self.log_ops):

                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[1])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, failure)
            else:
                self.expression_breakdown(tmpNode, success, failure)

        elif index == 1:
            # AND
            tmp_label = max(self.labelList)
            self.labelList.append(tmp_label+1)
            tmpNode = root.children[0]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[0])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, tmp_label, failure)
            else:
                self.expression_breakdown(tmpNode, tmp_label, failure)

            self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

            tmpNode = root.children[1]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[1])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, failure)
            else:
                self.expression_breakdown(tmpNode, success, failure)

    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in self.treeList])

    @staticmethod
    def singleEntry(irNode, labelDigit=None, prefix=&#34;&#34;):
        &#34;&#34;&#34;
        Creates a new instance of an IRLine but with only one entry.

        Args:
            irNode: The given &#39;IRNode&#39; entry for this new IRLine.
            labelList: The list of used label names.
            prefix: The output prefix.
        &#34;&#34;&#34;
        entry = IRLine(node=None, tvs=[], labelList=[labelDigit], prefix=prefix)
        entry.treeList.append(irNode)
        return entry

class IRNode():
    &#34;&#34;&#34;
    Abstract intermediate representation node. Base class for all other IR representations other than IRLines.
    &#34;&#34;&#34;
    def __init__(self):
        pass

    def __str__(self):
        pass

    def asm(self):
        pass


class IRJump(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a jump label.
    &#34;&#34;&#34;
    def __init__(self, name):
        &#34;&#34;&#34;
        Args:
            name: Name of the jump label
        &#34;&#34;&#34;
        self.name = name

    def __str__(self):
        return f&#34;{self.name}:&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRJump
        &#34;&#34;&#34;
        return [asmn.ASMNode(f&#34;{self.name.replace(&#39;&lt;&#39;,&#39;&#39;).replace(&#39;&gt;&#39;,&#39;&#39;)}:&#34;,None,None,dontTouch=True)]


class IRGoTo(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a goto label.
    &#34;&#34;&#34;
    def __init__(self, name):
        &#34;&#34;&#34;
        Args:
            name: Name of the label which is jumped to
        &#34;&#34;&#34;
        self.name = name

    def __str__(self):
        return f&#34;goto {self.name};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRGoTo
        &#34;&#34;&#34;

        return [asmn.ASMNode(&#34;jmp&#34;, self.name.replace(&#34;&lt;&#34;,&#34;&#34;).replace(&#34;&gt;&#34;,&#34;&#34;), None, dontTouch=True)]

class IRIf(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an if statement. If statements are constructed to represent actual If Statements, While Loops, and For Loops in C.
    &#34;&#34;&#34;
    def __init__(self, node, success, failure, ops):
        &#34;&#34;&#34;
        Args:
            node: `AST-node` for the given
            success: Success label digit
            failure: Failure label digit
            ops: The potential complex operands for the left/right hand side of the comparison
        &#34;&#34;&#34;
        if(node == None and success == None and failure == None and ops == None):
            pass
        else:
            self.node = node
            self.success = success
            self.failure = failure
            self.children = []

            self.comp = node.name
            self.lhs = None
            self.rhs = None

            # Case 1: ops is empty
            if ops == [] and len(node.children) &gt; 1:
                self.lhs = node.children[0].name
                self.rhs = node.children[1].name

            # Case 2: two elem in ops
            elif len(ops) == 2:
                self.lhs = ops[1]
                self.rhs = ops[0]

            else:
                pos = [node.children.index(x) for x in node.children if len(x.children) != 0 and len(node.children) &gt; 1]

                # Case 3: one elem in ops but its the left element in the operation
                if pos == [0]:
                    self.lhs = ops[0]
                    self.rhs = node.children[1].name

                # Case 4: one elem in ops but its the right element in the operation
                elif pos == [1]:
                    self.lhs = node.children[0].name
                    self.rhs = ops[0]

    def __str__(self):
        return f&#34;if ({self.lhs} {self.comp} {self.rhs}) goto &lt;D.{self.success}&gt;; else goto &lt;D.{self.failure}&gt;;&#34;
    def fileInit(self,lhs,rhs,compOp,succ,fail):
        &#34;&#34;&#34;
        Args:
            lhs: left side of the comparison
            rhs: right side of the comparison
            compOp: comparison operator
            succ: success label
            fail: failure label
        &#34;&#34;&#34;
        self.lhs = lhs
        self.rhs = rhs
        self.comp = compOp
        self.success = succ
        self.failure = fail

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRIf
        &#34;&#34;&#34;

        l = []

        i = 0
        v1 = self.lhs
        v2 = self.rhs

        c_op = &#34;&#34;
        j_op = &#34;&#34;

        try:
            v1 = int(v1)
        except ValueError:
            try:
                v1 = float(v1)
            except ValueError:
                pass

        try:
            v2 = int(v2)
        except ValueError:
            try:
                v2 = float(v2)
            except ValueError:
                pass

        if v1 == v2:
            if self.comp in [&#34;==&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;]:
                return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.success}&#34;, None, dontTouch=True)]
            else:
                return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None, dontTouch=True)]
        else:

            if isinstance(v1, int):
                if v1 == 0:
                    l.append(asmn.ASMNode(&#34;xor&#34;, None, None, leftNeedsReg=True, rightNeedsReg=True))
                    v1 = None
                else:
                    l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v1}&#34;, None, rightNeedsReg=True))
                    v1 = f&#34;${v1}&#34;
            if isinstance(v2, int):
                if v2 == 0:
                    l.append(asmn.ASMNode(&#34;xor&#34;,  None, None, leftNeedsReg=True, rightNeedsReg=True))
                    v2 = None
                else:
                    l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v2}&#34;, None, rightNeedsReg=True))
                    v2 = f&#34;${v2}&#34;

        if self.comp == &#34;==&#34;:
            c_op = &#34;test&#34;
            j_op = &#34;je&#34;
        elif self.comp == &#34;!=&#34;:
            c_op = &#34;test&#34;
            j_op = &#34;jne&#34;
        elif self.comp == &#34;&lt;=&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jle&#34;
        elif self.comp == &#34;&gt;=&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jge&#34;
        elif self.comp == &#34;&lt;&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jl&#34;
        elif self.comp == &#34;&gt;&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jg&#34;
        l.append(asmn.ASMNode(c_op, v1, v2, leftNeedsReg=True, rightNeedsReg=True))
        l.append(asmn.ASMNode(j_op, f&#34;D.{self.success}&#34;, None, dontTouch=True))
        l.append(asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None,dontTouch = True))

        return l

class IRArth(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an arithmetic/assignment operation.
    &#34;&#34;&#34;
    def __init__(self, node, ops, varName):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the arithmetical expression
            ops: The potential complex operands for the expression
            tvs: The tempoary variable stack
        &#34;&#34;&#34;
        if(node == None and ops == None):
            pass
        else:
            self.node = node
            self.var = varName

            self.operator = node.name
            self.lhs = None
            self.rhs = None

            # Case 1: ops is empty
            if ops == [] and len(node.children) &gt; 1:
                self.lhs = node.children[0].name
                self.rhs = node.children[1].name
            # Case 2: two elem in ops
            elif len(ops) == 2:
                self.lhs = ops[1]
                self.rhs = ops[0]
            else:
                pos = [node.children.index(x) for x in node.children if len(x.children) != 0 and len(node.children) &gt; 1]

                # Case 3: one elem in ops but its the left element in the operation
                if pos == [0]:
                    self.lhs = ops[0]
                    self.rhs = node.children[1].name
                # Case 4: one elem in ops but its the right element in the operation
                elif pos == [1]:
                    self.lhs = node.children[0].name
                    self.rhs = ops[0]
                # Case 5: Its a unary operator.
                elif pos == []:
                    self.lhs = ops[0] if ops != [] else node.children[0].name

    def __str__(self):
        if self.rhs:
            return f&#34;{self.var} = {self.lhs} {self.operator} {self.rhs};&#34;
        else:
            return f&#34;{self.var} = {self.operator}{self.lhs};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRArht node
        &#34;&#34;&#34;

        l = []

        i = 0
        spec_op = False

        v1 = self.lhs
        v2 = self.rhs

        asm_op = &#34;&#34;

        try:
            v1 = int(v1)
        except ValueError:
            try:
                v1 = float(v1)
            except ValueError:
                pass

        if v2:
            try:
                v2 = int(v2)
            except ValueError:
                try:
                    v2 = float(v2)
                except ValueError:
                    pass

        v1InReg = False
        v2InReg = False

        if isinstance(v1, int):
            v1 = f&#34;${v1}&#34;
        if isinstance(v2, int):
            if v2 == 0:
                l.append(asmn.ASMNode(&#34;xor&#34;,  self.var,  self.var, leftNeedsReg=True, rightNeedsReg=True))
            v2 = f&#34;${v2}&#34;

        if self.operator == &#34;+&#34;:
            asm_op = &#34;add&#34;
            if v2 == None:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                ])
                spec_op = True
        elif self.operator == &#34;-&#34;:
            if v2 == None:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                    asmn.ASMNode(&#34;neg&#34;, self.var, None, leftNeedsReg=True),
                ])
                spec_op = True
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var),
                    asmn.ASMNode(&#34;sub&#34;, v2, self.var)
                ])
                spec_op = True
        elif self.operator == &#34;*&#34;:
            asm_op = &#34;imul&#34;
            if v1.startswith(&#34;$&#34;):
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;,v2,self.var),
                    asmn.ASMNode(&#34;imul&#34;,self.var,self.var,aux=v1)
                ])
                spec_op = True
        elif self.operator == &#34;/&#34;:
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
            l.extend([
                asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
                asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var)
            ])
            spec_op = True
        elif self.operator == &#34;%&#34;:
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
            l.extend([
                asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
                asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rdx&#34;, self.var)
            ])
            spec_op = True
        elif self.operator == &#34;&lt;&lt;&#34;:
            asm_op = &#34;sal&#34;
            l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;sal&#34;, v2, self.var))
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                    asmn.ASMNode(&#34;sal&#34;, &#34;cl&#34;, self.var)
                ])
            spec_op = True
        elif self.operator == &#34;&gt;&gt;&#34;:
            asm_op = &#34;sar&#34;
            l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;sar&#34;, v2, self.var))
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                    asmn.ASMNode(&#34;sar&#34;, &#34;cl&#34;, self.var)
                ])
            spec_op = True
        elif self.operator == &#34;|&#34;:
            asm_op = &#34;or&#34;
        elif self.operator == &#34;&amp;&#34;:
            asm_op = &#34;and&#34;
        elif self.operator == &#34;^&#34;:
            asm_op = &#34;xor&#34;
        elif self.operator == &#34;!&#34;:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                asmn.ASMNode(&#34;xor&#34;, &#34;rax&#34;, &#34;rax&#34;, dontTouch=True),
                asmn.ASMNode(&#34;test&#34;, self.var, self.var, leftNeedsReg=True, rightNeedsReg=True),
                asmn.ASMNode(&#34;sete&#34;, &#34;al&#34;, None, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var, rightNeedsReg=True)
            ])
            spec_op = True
        elif self.operator == &#34;~&#34;:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                asmn.ASMNode(&#34;not&#34;, self.var, None, leftNeedsReg=True),
                ])
            spec_op = True

        if not spec_op:

            if v2 != self.var:
                l.append(
                    asmn.ASMNode(&#34;mov&#34;, v2, self.var, rightNeedsReg=True)
                )
                v2 = self.var

            l.extend([
                asmn.ASMNode(asm_op, v1, v2, rightNeedsReg=True),
            ])

        return l

    def fileInit(self,leftHand,op,rightHand,varName):
        &#34;&#34;&#34;
        Args:
            leftHand: Left hand side of the op.
            op: The operator of the arithmatic function
            rightHand: Right hand side of the op.
            varname: Name of the variable
        &#34;&#34;&#34;
        self.lhs = leftHand
        self.rhs = rightHand
        self.operator = op
        self.var = varName

class IRSpecial(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a special operation assignment. Special operations consist of pre/post increment and decrement operations.
    &#34;&#34;&#34;
    def __init__(self, node, var):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the operation
            var: The variable which the operation is applied to
        &#34;&#34;&#34;
        self.node = node
        self.var = var
        self.operation = self.node.name[0]


    def __str__(self):
        return f&#34;{self.var} = {self.var} {self.operation} 1;&#34;

    def asm(self):
        &#34;&#34;&#34;
        Constructs assembly string of a special (i.e. inc/dec) instruction
        Returns:
            List of necessary ASMNodes representing assembly code.
        &#34;&#34;&#34;

        if self.operation == &#34;+&#34;:
            return [asmn.ASMNode(&#34;inc&#34;, self.var, None)]
        elif self.operation == &#39;-&#39;:
            return [asmn.ASMNode(&#34;dec&#34;, self.var, None)]



class IRAssignment(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an assignment operation.
    &#34;&#34;&#34;
    def __init__(self, lhs, rhs):
        &#34;&#34;&#34;
        Args:
            lhs: The left hand side of the assignment
            rhs: The right hand side of the assignment
        &#34;&#34;&#34;
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} = {self.rhs};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRAssignment
        &#34;&#34;&#34;
        l = []

        op = &#34;mov&#34;
        v = self.rhs

        try:
            v = int(self.rhs)

            if v == 0:
                return [asmn.ASMNode(&#34;xor&#34;, self.lhs, self.lhs)]
            else:
                return [asmn.ASMNode(&#34;mov&#34;, f&#34;${v}&#34;, self.lhs)]
        except ValueError:
            try:
                v = float(self.rhs)
                modif = &#34;$&#34;
            except ValueError:
                return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs,leftNeedsReg=True, rightNeedsReg=True)]
                pass
            # TODO: Understand how floating point registers work while not going bald like ben.
        return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs)]

class IRFunctionAssign(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a function call assignment.
    &#34;&#34;&#34;
    def __init__(self, node, params, varName):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the funtion
            params: A list of parameters for the function call
            tvs: The tempoary variable stack
        &#34;&#34;&#34;
        if(node == None and params == None):
            pass
        else:
            self.node = node
            self.name = self.node.children[0].name
            self.params = params
            self.lhs = varName

    def __str__(self):
        return f&#34;{self.lhs} = {self.name}({&#39;, &#39;.join(self.params)});&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRFunctionAssign
        &#34;&#34;&#34;
        asm_calls = []

        fourByteRegisters = [&#34;rdi&#34;, &#34;rsi&#34;, &#34;rdx&#34;, &#34;rcx&#34;, &#34;r8&#34;, &#34;r9&#34;]

        push_param = [x for i, x in enumerate(self.params) if i &gt;= 6]
        reg_param = [x for i, x in enumerate(self.params) if i &lt; 6]
        reg_param.reverse()

        for x in push_param:
            try:
                x = f&#34;${int(x)}&#34;
            except ValueError:
                pass
            asm_calls.append(asmn.ASMNode(&#34;push&#34;, x, None, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False, dontTouch=True))

        while len(fourByteRegisters) &gt; len(reg_param):
            fourByteRegisters.pop()

        for x in reg_param:
            try:
                x = f&#34;${int(x)}&#34;
            except ValueError:
                pass
            asm_calls.append(asmn.ASMNode(&#34;mov&#34;, x, fourByteRegisters.pop(), regIsParam=True, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False))

        asm_calls.extend([
            asmn.ASMNode(&#34;call&#34;, self.name, None, dontTouch=True),
            asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.lhs)
        ])

        return asm_calls

    def LineFromFile(self,lhs,func_name,params):
        &#34;&#34;&#34;
        Args:
            lhs: left hand side of the assignment.
            func_name: name of the function call.
            params: parameters of the function call.
        &#34;&#34;&#34;
        self.lhs = lhs
        self.name = func_name
        self.params = params


class IRFunctionDecl(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a function declaration.
    &#34;&#34;&#34;
    def __init__(self, name, params):
        &#34;&#34;&#34;
        Args:
            name: Name of function call.
            params: The function params as a string
        &#34;&#34;&#34;
        self.name = name
        self.params = params

    def __str__(self):
        return f&#34;{self.name} ({&#39;, &#39;.join(self.params)})&#34;

    def asm(self):
        &#34;&#34;&#34;
        Constructs assembly Nodes of a function declaration

        Returns:
            List of ASM Nodes representing assembly code.
        &#34;&#34;&#34;

        # value: register name
        # key: used/unused (1/0)
        fourByteRegisters = {&#34;rdi&#34;: 0, &#34;rsi&#34;: 0, &#34;rdx&#34;: 0, &#34;rcx&#34;: 0, &#34;r8&#34;: 0, &#34;r9&#34;: 0}
        eightByteRegisters = {&#34;XMM0&#34;: 0, &#34;XMM1&#34;: 0, &#34;XMM2&#34;: 0, &#34;XMM3&#34;: 0, &#34;XMM4&#34;: 0, &#34;XMM5&#34;: 0, &#34;XMM6&#34;: 0, &#34;XMM7&#34;: 0}

        asmLs = []

        regdir = {}
        stack = []

        for idx, var in enumerate(self.params):
            if idx &lt; 6:
                source_reg = [x for x, y in fourByteRegisters.items() if y == 0][0]
                fourByteRegisters[source_reg] = 1

                regdir[source_reg] = var.split(&#39; &#39;)[-1]
            else:
                stack.append(stk.stackObj(Type=&#34;KnownVar&#34;, Name=var.split(&#39; &#39;)[-1]))

        asmLs.extend([
            asmn.ASMNode(None, None, None,boilerPlate=f&#34;.globl\t{self.name}&#34;),
            asmn.ASMNode(None, None, None,boilerPlate=f&#34;.type\t{self.name},\t@function&#34;),
            asmn.ASMNode(f&#34;{self.name}:&#34;,None,None, functionDecl=True, regDir=regdir, stack=stack),
            asmn.ASMNode(&#34;mov&#34;, &#34;rsp&#34;, &#34;rbp&#34;, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;rbx&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r12&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r13&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r14&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r15&#34;, None, dontTouch=True),
        ])

        return asmLs

class IRReturn(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a return.
    &#34;&#34;&#34;
    def __init__(self, value):
        &#34;&#34;&#34;
        Args:
            value: The return value. Can be &#39;None&#39; for void functions.
        &#34;&#34;&#34;
        self.value = value

    def __str__(self):
        if self.value:
            return f&#34;return {self.value};&#34;
        else:
            return f&#34;return;&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRReturn
        &#34;&#34;&#34;

        asml = []
        if self.value:
            asml.append(asmn.ASMNode(&#34;mov&#34;, self.value, &#34;rax&#34;))
        asml.extend([
            asmn.ASMNode(&#34;ret&#34;, None, None, dontTouch=True)
        ])

        return asml

class IRBracket(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a bracket
    &#34;&#34;&#34;
    def __init__(self, opening, functionDecl=False):
        &#34;&#34;&#34;
        Args:
            opening: Either True or False depending on if bracket is open/close
        &#34;&#34;&#34;
        self.opening = opening
        self.functionDecl = functionDecl

    def __str__(self):
        if self.opening == True:
            return &#34;{&#34;
        else:
            return &#34;}&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRBracket
        &#34;&#34;&#34;

        if self.functionDecl:
            return []
        else:
            return []
        # TODO: determine how many local variables exist within the scope in order to move the stack pointer.

class IRVariableInit(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a variable initialization.
    &#34;&#34;&#34;
    def __init__(self, modifiers, typ, var):
        &#34;&#34;&#34;
        Args:
            modifiers:
            type:
            var:
        &#34;&#34;&#34;
        self.modifiers = modifiers

        self.typ = typ

        self.var = var

    def __str__(self):
        return f&#34;{self.modifiers}{self.typ} {self.var};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRVariableInit
        &#34;&#34;&#34;

        return []</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.optimizer.IRLine.IRArth"><code class="flex name class">
<span>class <span class="ident">IRArth</span></span>
<span>(</span><span>node, ops, varName)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for an arithmetic/assignment operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node for the arithmetical expression</dd>
<dt><strong><code>ops</code></strong></dt>
<dd>The potential complex operands for the expression</dd>
<dt><strong><code>tvs</code></strong></dt>
<dd>The tempoary variable stack</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRArth(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an arithmetic/assignment operation.
    &#34;&#34;&#34;
    def __init__(self, node, ops, varName):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the arithmetical expression
            ops: The potential complex operands for the expression
            tvs: The tempoary variable stack
        &#34;&#34;&#34;
        if(node == None and ops == None):
            pass
        else:
            self.node = node
            self.var = varName

            self.operator = node.name
            self.lhs = None
            self.rhs = None

            # Case 1: ops is empty
            if ops == [] and len(node.children) &gt; 1:
                self.lhs = node.children[0].name
                self.rhs = node.children[1].name
            # Case 2: two elem in ops
            elif len(ops) == 2:
                self.lhs = ops[1]
                self.rhs = ops[0]
            else:
                pos = [node.children.index(x) for x in node.children if len(x.children) != 0 and len(node.children) &gt; 1]

                # Case 3: one elem in ops but its the left element in the operation
                if pos == [0]:
                    self.lhs = ops[0]
                    self.rhs = node.children[1].name
                # Case 4: one elem in ops but its the right element in the operation
                elif pos == [1]:
                    self.lhs = node.children[0].name
                    self.rhs = ops[0]
                # Case 5: Its a unary operator.
                elif pos == []:
                    self.lhs = ops[0] if ops != [] else node.children[0].name

    def __str__(self):
        if self.rhs:
            return f&#34;{self.var} = {self.lhs} {self.operator} {self.rhs};&#34;
        else:
            return f&#34;{self.var} = {self.operator}{self.lhs};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRArht node
        &#34;&#34;&#34;

        l = []

        i = 0
        spec_op = False

        v1 = self.lhs
        v2 = self.rhs

        asm_op = &#34;&#34;

        try:
            v1 = int(v1)
        except ValueError:
            try:
                v1 = float(v1)
            except ValueError:
                pass

        if v2:
            try:
                v2 = int(v2)
            except ValueError:
                try:
                    v2 = float(v2)
                except ValueError:
                    pass

        v1InReg = False
        v2InReg = False

        if isinstance(v1, int):
            v1 = f&#34;${v1}&#34;
        if isinstance(v2, int):
            if v2 == 0:
                l.append(asmn.ASMNode(&#34;xor&#34;,  self.var,  self.var, leftNeedsReg=True, rightNeedsReg=True))
            v2 = f&#34;${v2}&#34;

        if self.operator == &#34;+&#34;:
            asm_op = &#34;add&#34;
            if v2 == None:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                ])
                spec_op = True
        elif self.operator == &#34;-&#34;:
            if v2 == None:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                    asmn.ASMNode(&#34;neg&#34;, self.var, None, leftNeedsReg=True),
                ])
                spec_op = True
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v1, self.var),
                    asmn.ASMNode(&#34;sub&#34;, v2, self.var)
                ])
                spec_op = True
        elif self.operator == &#34;*&#34;:
            asm_op = &#34;imul&#34;
            if v1.startswith(&#34;$&#34;):
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;,v2,self.var),
                    asmn.ASMNode(&#34;imul&#34;,self.var,self.var,aux=v1)
                ])
                spec_op = True
        elif self.operator == &#34;/&#34;:
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
            l.extend([
                asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
                asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var)
            ])
            spec_op = True
        elif self.operator == &#34;%&#34;:
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
            l.extend([
                asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
                asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rdx&#34;, self.var)
            ])
            spec_op = True
        elif self.operator == &#34;&lt;&lt;&#34;:
            asm_op = &#34;sal&#34;
            l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;sal&#34;, v2, self.var))
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                    asmn.ASMNode(&#34;sal&#34;, &#34;cl&#34;, self.var)
                ])
            spec_op = True
        elif self.operator == &#34;&gt;&gt;&#34;:
            asm_op = &#34;sar&#34;
            l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
            if v2.startswith(&#34;$&#34;):
                l.append(asmn.ASMNode(&#34;sar&#34;, v2, self.var))
            else:
                l.extend([
                    asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                    asmn.ASMNode(&#34;sar&#34;, &#34;cl&#34;, self.var)
                ])
            spec_op = True
        elif self.operator == &#34;|&#34;:
            asm_op = &#34;or&#34;
        elif self.operator == &#34;&amp;&#34;:
            asm_op = &#34;and&#34;
        elif self.operator == &#34;^&#34;:
            asm_op = &#34;xor&#34;
        elif self.operator == &#34;!&#34;:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                asmn.ASMNode(&#34;xor&#34;, &#34;rax&#34;, &#34;rax&#34;, dontTouch=True),
                asmn.ASMNode(&#34;test&#34;, self.var, self.var, leftNeedsReg=True, rightNeedsReg=True),
                asmn.ASMNode(&#34;sete&#34;, &#34;al&#34;, None, dontTouch=True),
                asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var, rightNeedsReg=True)
            ])
            spec_op = True
        elif self.operator == &#34;~&#34;:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                asmn.ASMNode(&#34;not&#34;, self.var, None, leftNeedsReg=True),
                ])
            spec_op = True

        if not spec_op:

            if v2 != self.var:
                l.append(
                    asmn.ASMNode(&#34;mov&#34;, v2, self.var, rightNeedsReg=True)
                )
                v2 = self.var

            l.extend([
                asmn.ASMNode(asm_op, v1, v2, rightNeedsReg=True),
            ])

        return l

    def fileInit(self,leftHand,op,rightHand,varName):
        &#34;&#34;&#34;
        Args:
            leftHand: Left hand side of the op.
            op: The operator of the arithmatic function
            rightHand: Right hand side of the op.
            varname: Name of the variable
        &#34;&#34;&#34;
        self.lhs = leftHand
        self.rhs = rightHand
        self.operator = op
        self.var = varName</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRArth.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <code>IRArht</code> <code>node</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRArht node
    &#34;&#34;&#34;

    l = []

    i = 0
    spec_op = False

    v1 = self.lhs
    v2 = self.rhs

    asm_op = &#34;&#34;

    try:
        v1 = int(v1)
    except ValueError:
        try:
            v1 = float(v1)
        except ValueError:
            pass

    if v2:
        try:
            v2 = int(v2)
        except ValueError:
            try:
                v2 = float(v2)
            except ValueError:
                pass

    v1InReg = False
    v2InReg = False

    if isinstance(v1, int):
        v1 = f&#34;${v1}&#34;
    if isinstance(v2, int):
        if v2 == 0:
            l.append(asmn.ASMNode(&#34;xor&#34;,  self.var,  self.var, leftNeedsReg=True, rightNeedsReg=True))
        v2 = f&#34;${v2}&#34;

    if self.operator == &#34;+&#34;:
        asm_op = &#34;add&#34;
        if v2 == None:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
            ])
            spec_op = True
    elif self.operator == &#34;-&#34;:
        if v2 == None:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
                asmn.ASMNode(&#34;neg&#34;, self.var, None, leftNeedsReg=True),
            ])
            spec_op = True
        else:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v1, self.var),
                asmn.ASMNode(&#34;sub&#34;, v2, self.var)
            ])
            spec_op = True
    elif self.operator == &#34;*&#34;:
        asm_op = &#34;imul&#34;
        if v1.startswith(&#34;$&#34;):
            l.extend([
                asmn.ASMNode(&#34;mov&#34;,v2,self.var),
                asmn.ASMNode(&#34;imul&#34;,self.var,self.var,aux=v1)
            ])
            spec_op = True
    elif self.operator == &#34;/&#34;:
        if v2.startswith(&#34;$&#34;):
            l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
        l.extend([
            asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
            asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
            asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
            asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var)
        ])
        spec_op = True
    elif self.operator == &#34;%&#34;:
        if v2.startswith(&#34;$&#34;):
            l.append(asmn.ASMNode(&#34;mov&#34;, v2, None, rightNeedsReg=True))
        l.extend([
            asmn.ASMNode(&#34;xor&#34;, &#34;rdx&#34;, &#34;rdx&#34;, dontTouch=True),
            asmn.ASMNode(&#34;mov&#34;, v1, &#34;rax&#34;),
            asmn.ASMNode(&#34;idiv&#34;, v2, None,leftNeedsReg=True),
            asmn.ASMNode(&#34;mov&#34;, &#34;rdx&#34;, self.var)
        ])
        spec_op = True
    elif self.operator == &#34;&lt;&lt;&#34;:
        asm_op = &#34;sal&#34;
        l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
        if v2.startswith(&#34;$&#34;):
            l.append(asmn.ASMNode(&#34;sal&#34;, v2, self.var))
        else:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;sal&#34;, &#34;cl&#34;, self.var)
            ])
        spec_op = True
    elif self.operator == &#34;&gt;&gt;&#34;:
        asm_op = &#34;sar&#34;
        l.append(asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True))
        if v2.startswith(&#34;$&#34;):
            l.append(asmn.ASMNode(&#34;sar&#34;, v2, self.var))
        else:
            l.extend([
                asmn.ASMNode(&#34;mov&#34;, v2, &#34;rcx&#34;, dontTouch=True),
                asmn.ASMNode(&#34;sar&#34;, &#34;cl&#34;, self.var)
            ])
        spec_op = True
    elif self.operator == &#34;|&#34;:
        asm_op = &#34;or&#34;
    elif self.operator == &#34;&amp;&#34;:
        asm_op = &#34;and&#34;
    elif self.operator == &#34;^&#34;:
        asm_op = &#34;xor&#34;
    elif self.operator == &#34;!&#34;:
        l.extend([
            asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
            asmn.ASMNode(&#34;xor&#34;, &#34;rax&#34;, &#34;rax&#34;, dontTouch=True),
            asmn.ASMNode(&#34;test&#34;, self.var, self.var, leftNeedsReg=True, rightNeedsReg=True),
            asmn.ASMNode(&#34;sete&#34;, &#34;al&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.var, rightNeedsReg=True)
        ])
        spec_op = True
    elif self.operator == &#34;~&#34;:
        l.extend([
            asmn.ASMNode(&#34;mov&#34;, v1, self.var, rightNeedsReg=True),
            asmn.ASMNode(&#34;not&#34;, self.var, None, leftNeedsReg=True),
            ])
        spec_op = True

    if not spec_op:

        if v2 != self.var:
            l.append(
                asmn.ASMNode(&#34;mov&#34;, v2, self.var, rightNeedsReg=True)
            )
            v2 = self.var

        l.extend([
            asmn.ASMNode(asm_op, v1, v2, rightNeedsReg=True),
        ])

    return l</code></pre>
</details>
</dd>
<dt id="src.optimizer.IRLine.IRArth.fileInit"><code class="name flex">
<span>def <span class="ident">fileInit</span></span>(<span>self, leftHand, op, rightHand, varName)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>leftHand</code></strong></dt>
<dd>Left hand side of the op.</dd>
<dt><strong><code>op</code></strong></dt>
<dd>The operator of the arithmatic function</dd>
<dt><strong><code>rightHand</code></strong></dt>
<dd>Right hand side of the op.</dd>
<dt><strong><code>varname</code></strong></dt>
<dd>Name of the variable</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fileInit(self,leftHand,op,rightHand,varName):
    &#34;&#34;&#34;
    Args:
        leftHand: Left hand side of the op.
        op: The operator of the arithmatic function
        rightHand: Right hand side of the op.
        varname: Name of the variable
    &#34;&#34;&#34;
    self.lhs = leftHand
    self.rhs = rightHand
    self.operator = op
    self.var = varName</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRAssignment"><code class="flex name class">
<span>class <span class="ident">IRAssignment</span></span>
<span>(</span><span>lhs, rhs)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for an assignment operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lhs</code></strong></dt>
<dd>The left hand side of the assignment</dd>
<dt><strong><code>rhs</code></strong></dt>
<dd>The right hand side of the assignment</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRAssignment(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an assignment operation.
    &#34;&#34;&#34;
    def __init__(self, lhs, rhs):
        &#34;&#34;&#34;
        Args:
            lhs: The left hand side of the assignment
            rhs: The right hand side of the assignment
        &#34;&#34;&#34;
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} = {self.rhs};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRAssignment
        &#34;&#34;&#34;
        l = []

        op = &#34;mov&#34;
        v = self.rhs

        try:
            v = int(self.rhs)

            if v == 0:
                return [asmn.ASMNode(&#34;xor&#34;, self.lhs, self.lhs)]
            else:
                return [asmn.ASMNode(&#34;mov&#34;, f&#34;${v}&#34;, self.lhs)]
        except ValueError:
            try:
                v = float(self.rhs)
                modif = &#34;$&#34;
            except ValueError:
                return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs,leftNeedsReg=True, rightNeedsReg=True)]
                pass
            # TODO: Understand how floating point registers work while not going bald like ben.
        return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRAssignment.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRAssignment" href="#src.optimizer.IRLine.IRAssignment"><code>IRAssignment</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRAssignment
    &#34;&#34;&#34;
    l = []

    op = &#34;mov&#34;
    v = self.rhs

    try:
        v = int(self.rhs)

        if v == 0:
            return [asmn.ASMNode(&#34;xor&#34;, self.lhs, self.lhs)]
        else:
            return [asmn.ASMNode(&#34;mov&#34;, f&#34;${v}&#34;, self.lhs)]
    except ValueError:
        try:
            v = float(self.rhs)
            modif = &#34;$&#34;
        except ValueError:
            return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs,leftNeedsReg=True, rightNeedsReg=True)]
            pass
        # TODO: Understand how floating point registers work while not going bald like ben.
    return [asmn.ASMNode(op, f&#34;{v}&#34;, self.lhs)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRBracket"><code class="flex name class">
<span>class <span class="ident">IRBracket</span></span>
<span>(</span><span>opening, functionDecl=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a bracket</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>opening</code></strong></dt>
<dd>Either True or False depending on if bracket is open/close</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRBracket(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a bracket
    &#34;&#34;&#34;
    def __init__(self, opening, functionDecl=False):
        &#34;&#34;&#34;
        Args:
            opening: Either True or False depending on if bracket is open/close
        &#34;&#34;&#34;
        self.opening = opening
        self.functionDecl = functionDecl

    def __str__(self):
        if self.opening == True:
            return &#34;{&#34;
        else:
            return &#34;}&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRBracket
        &#34;&#34;&#34;

        if self.functionDecl:
            return []
        else:
            return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRBracket.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRBracket" href="#src.optimizer.IRLine.IRBracket"><code>IRBracket</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRBracket
    &#34;&#34;&#34;

    if self.functionDecl:
        return []
    else:
        return []</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRFunctionAssign"><code class="flex name class">
<span>class <span class="ident">IRFunctionAssign</span></span>
<span>(</span><span>node, params, varName)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a function call assignment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node for the funtion</dd>
<dt><strong><code>params</code></strong></dt>
<dd>A list of parameters for the function call</dd>
<dt><strong><code>tvs</code></strong></dt>
<dd>The tempoary variable stack</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRFunctionAssign(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a function call assignment.
    &#34;&#34;&#34;
    def __init__(self, node, params, varName):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the funtion
            params: A list of parameters for the function call
            tvs: The tempoary variable stack
        &#34;&#34;&#34;
        if(node == None and params == None):
            pass
        else:
            self.node = node
            self.name = self.node.children[0].name
            self.params = params
            self.lhs = varName

    def __str__(self):
        return f&#34;{self.lhs} = {self.name}({&#39;, &#39;.join(self.params)});&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRFunctionAssign
        &#34;&#34;&#34;
        asm_calls = []

        fourByteRegisters = [&#34;rdi&#34;, &#34;rsi&#34;, &#34;rdx&#34;, &#34;rcx&#34;, &#34;r8&#34;, &#34;r9&#34;]

        push_param = [x for i, x in enumerate(self.params) if i &gt;= 6]
        reg_param = [x for i, x in enumerate(self.params) if i &lt; 6]
        reg_param.reverse()

        for x in push_param:
            try:
                x = f&#34;${int(x)}&#34;
            except ValueError:
                pass
            asm_calls.append(asmn.ASMNode(&#34;push&#34;, x, None, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False, dontTouch=True))

        while len(fourByteRegisters) &gt; len(reg_param):
            fourByteRegisters.pop()

        for x in reg_param:
            try:
                x = f&#34;${int(x)}&#34;
            except ValueError:
                pass
            asm_calls.append(asmn.ASMNode(&#34;mov&#34;, x, fourByteRegisters.pop(), regIsParam=True, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False))

        asm_calls.extend([
            asmn.ASMNode(&#34;call&#34;, self.name, None, dontTouch=True),
            asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.lhs)
        ])

        return asm_calls

    def LineFromFile(self,lhs,func_name,params):
        &#34;&#34;&#34;
        Args:
            lhs: left hand side of the assignment.
            func_name: name of the function call.
            params: parameters of the function call.
        &#34;&#34;&#34;
        self.lhs = lhs
        self.name = func_name
        self.params = params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRFunctionAssign.LineFromFile"><code class="name flex">
<span>def <span class="ident">LineFromFile</span></span>(<span>self, lhs, func_name, params)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>lhs</code></strong></dt>
<dd>left hand side of the assignment.</dd>
<dt><strong><code>func_name</code></strong></dt>
<dd>name of the function call.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>parameters of the function call.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LineFromFile(self,lhs,func_name,params):
    &#34;&#34;&#34;
    Args:
        lhs: left hand side of the assignment.
        func_name: name of the function call.
        params: parameters of the function call.
    &#34;&#34;&#34;
    self.lhs = lhs
    self.name = func_name
    self.params = params</code></pre>
</details>
</dd>
<dt id="src.optimizer.IRLine.IRFunctionAssign.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRFunctionAssign" href="#src.optimizer.IRLine.IRFunctionAssign"><code>IRFunctionAssign</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRFunctionAssign
    &#34;&#34;&#34;
    asm_calls = []

    fourByteRegisters = [&#34;rdi&#34;, &#34;rsi&#34;, &#34;rdx&#34;, &#34;rcx&#34;, &#34;r8&#34;, &#34;r9&#34;]

    push_param = [x for i, x in enumerate(self.params) if i &gt;= 6]
    reg_param = [x for i, x in enumerate(self.params) if i &lt; 6]
    reg_param.reverse()

    for x in push_param:
        try:
            x = f&#34;${int(x)}&#34;
        except ValueError:
            pass
        asm_calls.append(asmn.ASMNode(&#34;push&#34;, x, None, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False, dontTouch=True))

    while len(fourByteRegisters) &gt; len(reg_param):
        fourByteRegisters.pop()

    for x in reg_param:
        try:
            x = f&#34;${int(x)}&#34;
        except ValueError:
            pass
        asm_calls.append(asmn.ASMNode(&#34;mov&#34;, x, fourByteRegisters.pop(), regIsParam=True, leftNeedsReg=True if not x.startswith(&#34;$&#34;) else False))

    asm_calls.extend([
        asmn.ASMNode(&#34;call&#34;, self.name, None, dontTouch=True),
        asmn.ASMNode(&#34;mov&#34;, &#34;rax&#34;, self.lhs)
    ])

    return asm_calls</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRFunctionDecl"><code class="flex name class">
<span>class <span class="ident">IRFunctionDecl</span></span>
<span>(</span><span>name, params)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a function declaration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of function call.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>The function params as a string</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRFunctionDecl(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a function declaration.
    &#34;&#34;&#34;
    def __init__(self, name, params):
        &#34;&#34;&#34;
        Args:
            name: Name of function call.
            params: The function params as a string
        &#34;&#34;&#34;
        self.name = name
        self.params = params

    def __str__(self):
        return f&#34;{self.name} ({&#39;, &#39;.join(self.params)})&#34;

    def asm(self):
        &#34;&#34;&#34;
        Constructs assembly Nodes of a function declaration

        Returns:
            List of ASM Nodes representing assembly code.
        &#34;&#34;&#34;

        # value: register name
        # key: used/unused (1/0)
        fourByteRegisters = {&#34;rdi&#34;: 0, &#34;rsi&#34;: 0, &#34;rdx&#34;: 0, &#34;rcx&#34;: 0, &#34;r8&#34;: 0, &#34;r9&#34;: 0}
        eightByteRegisters = {&#34;XMM0&#34;: 0, &#34;XMM1&#34;: 0, &#34;XMM2&#34;: 0, &#34;XMM3&#34;: 0, &#34;XMM4&#34;: 0, &#34;XMM5&#34;: 0, &#34;XMM6&#34;: 0, &#34;XMM7&#34;: 0}

        asmLs = []

        regdir = {}
        stack = []

        for idx, var in enumerate(self.params):
            if idx &lt; 6:
                source_reg = [x for x, y in fourByteRegisters.items() if y == 0][0]
                fourByteRegisters[source_reg] = 1

                regdir[source_reg] = var.split(&#39; &#39;)[-1]
            else:
                stack.append(stk.stackObj(Type=&#34;KnownVar&#34;, Name=var.split(&#39; &#39;)[-1]))

        asmLs.extend([
            asmn.ASMNode(None, None, None,boilerPlate=f&#34;.globl\t{self.name}&#34;),
            asmn.ASMNode(None, None, None,boilerPlate=f&#34;.type\t{self.name},\t@function&#34;),
            asmn.ASMNode(f&#34;{self.name}:&#34;,None,None, functionDecl=True, regDir=regdir, stack=stack),
            asmn.ASMNode(&#34;mov&#34;, &#34;rsp&#34;, &#34;rbp&#34;, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;rbx&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r12&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r13&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r14&#34;, None, dontTouch=True),
            asmn.ASMNode(&#34;push&#34;, &#34;r15&#34;, None, dontTouch=True),
        ])

        return asmLs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRFunctionDecl.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs assembly Nodes of a function declaration</p>
<h2 id="returns">Returns</h2>
<p>List of ASM Nodes representing assembly code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Constructs assembly Nodes of a function declaration

    Returns:
        List of ASM Nodes representing assembly code.
    &#34;&#34;&#34;

    # value: register name
    # key: used/unused (1/0)
    fourByteRegisters = {&#34;rdi&#34;: 0, &#34;rsi&#34;: 0, &#34;rdx&#34;: 0, &#34;rcx&#34;: 0, &#34;r8&#34;: 0, &#34;r9&#34;: 0}
    eightByteRegisters = {&#34;XMM0&#34;: 0, &#34;XMM1&#34;: 0, &#34;XMM2&#34;: 0, &#34;XMM3&#34;: 0, &#34;XMM4&#34;: 0, &#34;XMM5&#34;: 0, &#34;XMM6&#34;: 0, &#34;XMM7&#34;: 0}

    asmLs = []

    regdir = {}
    stack = []

    for idx, var in enumerate(self.params):
        if idx &lt; 6:
            source_reg = [x for x, y in fourByteRegisters.items() if y == 0][0]
            fourByteRegisters[source_reg] = 1

            regdir[source_reg] = var.split(&#39; &#39;)[-1]
        else:
            stack.append(stk.stackObj(Type=&#34;KnownVar&#34;, Name=var.split(&#39; &#39;)[-1]))

    asmLs.extend([
        asmn.ASMNode(None, None, None,boilerPlate=f&#34;.globl\t{self.name}&#34;),
        asmn.ASMNode(None, None, None,boilerPlate=f&#34;.type\t{self.name},\t@function&#34;),
        asmn.ASMNode(f&#34;{self.name}:&#34;,None,None, functionDecl=True, regDir=regdir, stack=stack),
        asmn.ASMNode(&#34;mov&#34;, &#34;rsp&#34;, &#34;rbp&#34;, dontTouch=True),
        asmn.ASMNode(&#34;push&#34;, &#34;rbx&#34;, None, dontTouch=True),
        asmn.ASMNode(&#34;push&#34;, &#34;r12&#34;, None, dontTouch=True),
        asmn.ASMNode(&#34;push&#34;, &#34;r13&#34;, None, dontTouch=True),
        asmn.ASMNode(&#34;push&#34;, &#34;r14&#34;, None, dontTouch=True),
        asmn.ASMNode(&#34;push&#34;, &#34;r15&#34;, None, dontTouch=True),
    ])

    return asmLs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRGoTo"><code class="flex name class">
<span>class <span class="ident">IRGoTo</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a goto label.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the label which is jumped to</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRGoTo(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a goto label.
    &#34;&#34;&#34;
    def __init__(self, name):
        &#34;&#34;&#34;
        Args:
            name: Name of the label which is jumped to
        &#34;&#34;&#34;
        self.name = name

    def __str__(self):
        return f&#34;goto {self.name};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRGoTo
        &#34;&#34;&#34;

        return [asmn.ASMNode(&#34;jmp&#34;, self.name.replace(&#34;&lt;&#34;,&#34;&#34;).replace(&#34;&gt;&#34;,&#34;&#34;), None, dontTouch=True)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRGoTo.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRGoTo" href="#src.optimizer.IRLine.IRGoTo"><code>IRGoTo</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRGoTo
    &#34;&#34;&#34;

    return [asmn.ASMNode(&#34;jmp&#34;, self.name.replace(&#34;&lt;&#34;,&#34;&#34;).replace(&#34;&gt;&#34;,&#34;&#34;), None, dontTouch=True)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRIf"><code class="flex name class">
<span>class <span class="ident">IRIf</span></span>
<span>(</span><span>node, success, failure, ops)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for an if statement. If statements are constructed to represent actual If Statements, While Loops, and For Loops in C.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd><code>AST-node</code> for the given</dd>
<dt><strong><code>success</code></strong></dt>
<dd>Success label digit</dd>
<dt><strong><code>failure</code></strong></dt>
<dd>Failure label digit</dd>
<dt><strong><code>ops</code></strong></dt>
<dd>The potential complex operands for the left/right hand side of the comparison</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRIf(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for an if statement. If statements are constructed to represent actual If Statements, While Loops, and For Loops in C.
    &#34;&#34;&#34;
    def __init__(self, node, success, failure, ops):
        &#34;&#34;&#34;
        Args:
            node: `AST-node` for the given
            success: Success label digit
            failure: Failure label digit
            ops: The potential complex operands for the left/right hand side of the comparison
        &#34;&#34;&#34;
        if(node == None and success == None and failure == None and ops == None):
            pass
        else:
            self.node = node
            self.success = success
            self.failure = failure
            self.children = []

            self.comp = node.name
            self.lhs = None
            self.rhs = None

            # Case 1: ops is empty
            if ops == [] and len(node.children) &gt; 1:
                self.lhs = node.children[0].name
                self.rhs = node.children[1].name

            # Case 2: two elem in ops
            elif len(ops) == 2:
                self.lhs = ops[1]
                self.rhs = ops[0]

            else:
                pos = [node.children.index(x) for x in node.children if len(x.children) != 0 and len(node.children) &gt; 1]

                # Case 3: one elem in ops but its the left element in the operation
                if pos == [0]:
                    self.lhs = ops[0]
                    self.rhs = node.children[1].name

                # Case 4: one elem in ops but its the right element in the operation
                elif pos == [1]:
                    self.lhs = node.children[0].name
                    self.rhs = ops[0]

    def __str__(self):
        return f&#34;if ({self.lhs} {self.comp} {self.rhs}) goto &lt;D.{self.success}&gt;; else goto &lt;D.{self.failure}&gt;;&#34;
    def fileInit(self,lhs,rhs,compOp,succ,fail):
        &#34;&#34;&#34;
        Args:
            lhs: left side of the comparison
            rhs: right side of the comparison
            compOp: comparison operator
            succ: success label
            fail: failure label
        &#34;&#34;&#34;
        self.lhs = lhs
        self.rhs = rhs
        self.comp = compOp
        self.success = succ
        self.failure = fail

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRIf
        &#34;&#34;&#34;

        l = []

        i = 0
        v1 = self.lhs
        v2 = self.rhs

        c_op = &#34;&#34;
        j_op = &#34;&#34;

        try:
            v1 = int(v1)
        except ValueError:
            try:
                v1 = float(v1)
            except ValueError:
                pass

        try:
            v2 = int(v2)
        except ValueError:
            try:
                v2 = float(v2)
            except ValueError:
                pass

        if v1 == v2:
            if self.comp in [&#34;==&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;]:
                return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.success}&#34;, None, dontTouch=True)]
            else:
                return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None, dontTouch=True)]
        else:

            if isinstance(v1, int):
                if v1 == 0:
                    l.append(asmn.ASMNode(&#34;xor&#34;, None, None, leftNeedsReg=True, rightNeedsReg=True))
                    v1 = None
                else:
                    l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v1}&#34;, None, rightNeedsReg=True))
                    v1 = f&#34;${v1}&#34;
            if isinstance(v2, int):
                if v2 == 0:
                    l.append(asmn.ASMNode(&#34;xor&#34;,  None, None, leftNeedsReg=True, rightNeedsReg=True))
                    v2 = None
                else:
                    l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v2}&#34;, None, rightNeedsReg=True))
                    v2 = f&#34;${v2}&#34;

        if self.comp == &#34;==&#34;:
            c_op = &#34;test&#34;
            j_op = &#34;je&#34;
        elif self.comp == &#34;!=&#34;:
            c_op = &#34;test&#34;
            j_op = &#34;jne&#34;
        elif self.comp == &#34;&lt;=&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jle&#34;
        elif self.comp == &#34;&gt;=&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jge&#34;
        elif self.comp == &#34;&lt;&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jl&#34;
        elif self.comp == &#34;&gt;&#34;:
            c_op = &#34;cmp&#34;
            j_op = &#34;jg&#34;
        l.append(asmn.ASMNode(c_op, v1, v2, leftNeedsReg=True, rightNeedsReg=True))
        l.append(asmn.ASMNode(j_op, f&#34;D.{self.success}&#34;, None, dontTouch=True))
        l.append(asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None,dontTouch = True))

        return l</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRIf.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRIf" href="#src.optimizer.IRLine.IRIf"><code>IRIf</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRIf
    &#34;&#34;&#34;

    l = []

    i = 0
    v1 = self.lhs
    v2 = self.rhs

    c_op = &#34;&#34;
    j_op = &#34;&#34;

    try:
        v1 = int(v1)
    except ValueError:
        try:
            v1 = float(v1)
        except ValueError:
            pass

    try:
        v2 = int(v2)
    except ValueError:
        try:
            v2 = float(v2)
        except ValueError:
            pass

    if v1 == v2:
        if self.comp in [&#34;==&#34;, &#34;&lt;=&#34;, &#34;&gt;=&#34;]:
            return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.success}&#34;, None, dontTouch=True)]
        else:
            return [asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None, dontTouch=True)]
    else:

        if isinstance(v1, int):
            if v1 == 0:
                l.append(asmn.ASMNode(&#34;xor&#34;, None, None, leftNeedsReg=True, rightNeedsReg=True))
                v1 = None
            else:
                l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v1}&#34;, None, rightNeedsReg=True))
                v1 = f&#34;${v1}&#34;
        if isinstance(v2, int):
            if v2 == 0:
                l.append(asmn.ASMNode(&#34;xor&#34;,  None, None, leftNeedsReg=True, rightNeedsReg=True))
                v2 = None
            else:
                l.append(asmn.ASMNode(&#34;mov&#34;, f&#34;${v2}&#34;, None, rightNeedsReg=True))
                v2 = f&#34;${v2}&#34;

    if self.comp == &#34;==&#34;:
        c_op = &#34;test&#34;
        j_op = &#34;je&#34;
    elif self.comp == &#34;!=&#34;:
        c_op = &#34;test&#34;
        j_op = &#34;jne&#34;
    elif self.comp == &#34;&lt;=&#34;:
        c_op = &#34;cmp&#34;
        j_op = &#34;jle&#34;
    elif self.comp == &#34;&gt;=&#34;:
        c_op = &#34;cmp&#34;
        j_op = &#34;jge&#34;
    elif self.comp == &#34;&lt;&#34;:
        c_op = &#34;cmp&#34;
        j_op = &#34;jl&#34;
    elif self.comp == &#34;&gt;&#34;:
        c_op = &#34;cmp&#34;
        j_op = &#34;jg&#34;
    l.append(asmn.ASMNode(c_op, v1, v2, leftNeedsReg=True, rightNeedsReg=True))
    l.append(asmn.ASMNode(j_op, f&#34;D.{self.success}&#34;, None, dontTouch=True))
    l.append(asmn.ASMNode(&#34;jmp&#34;, f&#34;D.{self.failure}&#34;, None,dontTouch = True))

    return l</code></pre>
</details>
</dd>
<dt id="src.optimizer.IRLine.IRIf.fileInit"><code class="name flex">
<span>def <span class="ident">fileInit</span></span>(<span>self, lhs, rhs, compOp, succ, fail)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>lhs</code></strong></dt>
<dd>left side of the comparison</dd>
<dt><strong><code>rhs</code></strong></dt>
<dd>right side of the comparison</dd>
<dt><strong><code>compOp</code></strong></dt>
<dd>comparison operator</dd>
<dt><strong><code>succ</code></strong></dt>
<dd>success label</dd>
<dt><strong><code>fail</code></strong></dt>
<dd>failure label</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fileInit(self,lhs,rhs,compOp,succ,fail):
    &#34;&#34;&#34;
    Args:
        lhs: left side of the comparison
        rhs: right side of the comparison
        compOp: comparison operator
        succ: success label
        fail: failure label
    &#34;&#34;&#34;
    self.lhs = lhs
    self.rhs = rhs
    self.comp = compOp
    self.success = succ
    self.failure = fail</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRJump"><code class="flex name class">
<span>class <span class="ident">IRJump</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a jump label.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the jump label</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRJump(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a jump label.
    &#34;&#34;&#34;
    def __init__(self, name):
        &#34;&#34;&#34;
        Args:
            name: Name of the jump label
        &#34;&#34;&#34;
        self.name = name

    def __str__(self):
        return f&#34;{self.name}:&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRJump
        &#34;&#34;&#34;
        return [asmn.ASMNode(f&#34;{self.name.replace(&#39;&lt;&#39;,&#39;&#39;).replace(&#39;&gt;&#39;,&#39;&#39;)}:&#34;,None,None,dontTouch=True)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRJump.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRJump" href="#src.optimizer.IRLine.IRJump"><code>IRJump</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRJump
    &#34;&#34;&#34;
    return [asmn.ASMNode(f&#34;{self.name.replace(&#39;&lt;&#39;,&#39;&#39;).replace(&#39;&gt;&#39;,&#39;&#39;)}:&#34;,None,None,dontTouch=True)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRLine"><code class="flex name class">
<span>class <span class="ident">IRLine</span></span>
<span>(</span><span>node, tvs=[], success=None, failure=None, labelList=[], prefix='')</span>
</code></dt>
<dd>
<section class="desc"><p>A class that contains all the intermediate representations for a given AST node. Will produce a linear representation when converted to a string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node corresponding to the collection of lines</dd>
<dt><strong><code>tvs</code></strong></dt>
<dd>The current tempoary variable storage</dd>
<dt><strong><code>success</code></strong></dt>
<dd>The success label</dd>
<dt><strong><code>failure</code></strong></dt>
<dd>The failure label</dd>
<dt><strong><code>labelList</code></strong></dt>
<dd>The list of used label names</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The output prefix</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRLine():
    &#34;&#34;&#34;
    A class that contains all the intermediate representations for a given AST node. Will produce a linear representation when converted to a string
    &#34;&#34;&#34;
    def __init__(self, node, tvs = [], success = None, failure = None, labelList = [], prefix = &#34;&#34;):
        &#34;&#34;&#34;
        Args:
            node: The AST node corresponding to the collection of lines
            tvs: The current tempoary variable storage
            success: The success label
            failure: The failure label
            labelList: The list of used label names
            prefix: The output prefix
        &#34;&#34;&#34;

        self.astNode = node
        self.treeList = []

        self.tvs = tvs
        self.labelList = labelList
        self.prefix = prefix

        self.log_ops = [&#39;||&#39;, &#39;&amp;&amp;&#39;]
        self.comp_ops = [&#34;&lt;=&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&gt;&#34;, &#34;==&#34;, &#34;!=&#34;]
        self.arth_ops = [&#34;+&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;%&#34;, &#34;&lt;&lt;&#34;, &#34;&gt;&gt;&#34;, &#34;|&#34;, &#34;&amp;&#34;, &#34;^&#34;, &#34;!&#34;, &#34;~&#34;]
        self.spec_ops = [&#34;++&#34;, &#34;--&#34;]
        self.ass_ops = [&#34;=&#34;, &#34;+=&#34;, &#34;-=&#34;, &#34;*=&#34;, &#34;/=&#34;, &#34;%=&#34;, &#34;&lt;&lt;=&#34;, &#34;&gt;&gt;=&#34;, &#34;|=&#34;, &#34;&amp;=&#34;, &#34;^=&#34;]
        self.id_ops = [&#34;var&#34;, &#34;call&#34;]

        # Based on the node construct the needed intermediate trees in order
        if node == None:
            # There was no AST node passed in. This is the case when there
            # are no complex IR instructions that need to be broken down.
            # IRNode will be added manually to self.treeList.
            pass

        elif node.name in self.log_ops:
            self.boolean_breakdown(self.astNode, success, failure)
        else:
            self.expression_breakdown(self.astNode, success, failure)


    def retrieve(self):
        &#34;&#34;&#34;
        Retrieves the updated tempoary variable storage and list of unavailable label names for the future.

        Returns:
            tvs: The current tempoary variable storage
            labelList: The list of used label names
        &#34;&#34;&#34;
        return self.tvs, self.labelList

    def expression_breakdown(self, root, success, failure):
        &#34;&#34;&#34;
        Breaks down smaller expressions in order to evaluate them

        Args:
            root: The root AST node
            success: The success label
            failure: The failure label
        &#34;&#34;&#34;
        if success not in self.labelList and success != None:
            self.labelList.append(success)
        if failure not in self.labelList and failure != None:
            self.labelList.append(failure)

        ns = root.list_POT()
        global tmpVarIndex
        ns = [x for x in ns if x.name in self.arth_ops or x.name in self.spec_ops or x.name in self.ass_ops or x.name in self.id_ops or x.name in self.comp_ops]
        for node in ns:
            if node.name in self.comp_ops:

                if node.name in self.comp_ops and node.parent != None and node.parent.name == &#34;!&#34;:
                    # logical not means we need to reverse this comparison
                    if node.name == &#34;&gt;&#34;: node.name = &#34;&lt;=&#34;
                    elif node.name == &#34;&lt;&#34;: node.name = &#34;&gt;=&#34;
                    elif node.name == &#34;==&#34;: node.name = &#34;!=&#34;
                    elif node.name == &#34;!=&#34;: node.name = &#34;==&#34;
                    elif node.name == &#34;&gt;=&#34;: node.name = &#34;&lt;&#34;
                    elif node.name == &#34;&lt;=&#34;: node.name = &#34;&gt;&#34;

                self.treeList.append(
                    IRIf(
                        node,
                        success,
                        failure,
                        [self.tvs.pop() for x in node.children if len(x.children) != 0]
                    )
                )

            elif node.name in self.arth_ops:
                tmpVarIndex += 1
                self.treeList.append(
                    IRArth(
                        node,
                        [self.tvs.pop() for x in node.children if len(x.children) != 0],
                        f&#34;tV_{tmpVarIndex}&#34;
                    )
                )

                self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

            elif node.name in self.spec_ops:
                var = self.tvs.pop()

                tmpVarIndex += 1

                # Create a temporay AST to deal with storing of the current value of the variable
                # tmpNode = ast.ASTNode(&#34;=&#34;, None)
                # tmpNode.children.append(ast.ASTNode(f&#34;_{tmpVarIndex}&#34;, tmpNode))
                # tmpNode.children.append(ast.ASTNode(var, tmpNode))

                self.treeList.append(
                    IRAssignment(
                        f&#34;tV_{tmpVarIndex}&#34;,
                        var
                    )
                )
                if [node.children.index(x) for x in node.children if x.name == &#34;NULL&#34;][0] == 1:
                    self.treeList.append(
                        IRSpecial(
                            node,
                            var
                        )
                    )
                else:
                    self.treeList.insert(len(self.treeList) - 2,
                        IRSpecial(
                            node,
                            var
                        )
                    )

                self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

            elif node.name in self.ass_ops:
                if self.ass_ops.index(node.name) == 0:
                    lhs = None
                    rhs = None
                    # Case 1: Assignment is constant. ie. int i = 0
                    if len(node.children[1].children) == 0:
                        lhs = self.tvs.pop()
                        rhs = f&#34;{node.children[1].name}&#34;
                    # Case 2: Assignment is complex
                    else:
                        lhs = f&#34;rV_{node.children[0].children[len(node.children[0].children)-1].name}&#34;
                        rhs = self.tvs.pop()

                    self.treeList.append(
                            IRAssignment(
                                lhs,
                                rhs
                            )
                        )
                else:
                    # create a temporary parent node
                    p = ast.ASTNode(&#34;=&#34;, None)

                    # append the variable who is assigned a value as its first child
                    p.children.append(node.children[0])

                    # create a right subtree with the correct operation
                    r = ast.ASTNode(node.name[:-1], p)
                    p.children.append(r)

                    rc = None
                    lc = None

                    # assign the variable as the left operand of the new expression
                    if len(node.children[1].children) &gt; 0:
                        rc = ast.ASTNode(self.tvs.pop(), r)
                    else:
                        rc = node.children[1]

                    # assign the variable as the left operand of the new expression
                    if len(node.children[0].children) &gt; 0:
                        lc = ast.ASTNode(self.tvs.pop(), r)
                    else:
                        lc = node.children[0]

                    # assign the remaining operations as the right operand of the new expression

                    r.children.append(lc)
                    r.children.append(rc)

                    self.expression_breakdown(p, success, failure)

            elif node.name in self.id_ops:
                if node.name == &#34;var&#34;:
                    self.tvs.append(f&#34;rV_{node.children[len(node.children)-1].name}&#34;)
                elif node.name == &#34;call&#34;:
                    # list of indices that correspond to the complex parameters of the function call
                    complexP = [node.children[0].children.index(x) for x in node.children[0].children if len(x.children) &gt; 0]
                    simpleP = [x for x in range(len(node.children[0].children)) if x not in complexP]

                    params = [self.tvs.pop() for x in range(len(node.children[0].children)) if x in complexP]

                    tmpVarIndex += 1
                    self.treeList.append(
                        IRFunctionAssign(
                            node,
                            [params.pop() if x in complexP else node.children[0].children[x].name for x in range(len(node.children[0].children))],
                            f&#34;tV_{tmpVarIndex}&#34;
                        )
                    )

                    self.tvs.append(self.treeList[-1].lhs)

    def boolean_breakdown(self, root, success, failure):
        &#34;&#34;&#34;
        Breaks down larger boolean expressions in order to evaluate them

        Args:
            root: The root AST node
            success: The success label
            failure: The failure label
        &#34;&#34;&#34;
        if success not in self.labelList and success != None:
            self.labelList.append(success)
        if failure not in self.labelList and failure != None:
            self.labelList.append(failure)

        index = self.log_ops.index(root.name)
        if index == 0:
            # OR
            tmp_label = max(self.labelList)
            self.labelList.append(tmp_label+1)
            tmpNode = root.children[0]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[0])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, tmp_label)
            else:
                self.expression_breakdown(tmpNode, success, tmp_label)

            self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

            tmpNode = root.children[1]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops and (
                tmpNode.children == [] or
                tmpNode.children[0].name not in self.comp_ops and tmpNode.children[0].name not in self.log_ops):

                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[1])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, failure)
            else:
                self.expression_breakdown(tmpNode, success, failure)

        elif index == 1:
            # AND
            tmp_label = max(self.labelList)
            self.labelList.append(tmp_label+1)
            tmpNode = root.children[0]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[0])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, tmp_label, failure)
            else:
                self.expression_breakdown(tmpNode, tmp_label, failure)

            self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

            tmpNode = root.children[1]
            if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
                tmpNode = ast.ASTNode(&#34;!=&#34;, None)
                tmpNode.children.append(root.children[1])
                tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

            if tmpNode.name in self.log_ops:
                self.boolean_breakdown(tmpNode, success, failure)
            else:
                self.expression_breakdown(tmpNode, success, failure)

    def __str__(self):
        return &#34;\n&#34;.join([str(x) for x in self.treeList])

    @staticmethod
    def singleEntry(irNode, labelDigit=None, prefix=&#34;&#34;):
        &#34;&#34;&#34;
        Creates a new instance of an IRLine but with only one entry.

        Args:
            irNode: The given &#39;IRNode&#39; entry for this new IRLine.
            labelList: The list of used label names.
            prefix: The output prefix.
        &#34;&#34;&#34;
        entry = IRLine(node=None, tvs=[], labelList=[labelDigit], prefix=prefix)
        entry.treeList.append(irNode)
        return entry</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRLine.singleEntry"><code class="name flex">
<span>def <span class="ident">singleEntry</span></span>(<span>irNode, labelDigit=None, prefix='')</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new instance of an IRLine but with only one entry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>irNode</code></strong></dt>
<dd>The given 'IRNode' entry for this new IRLine.</dd>
<dt><strong><code>labelList</code></strong></dt>
<dd>The list of used label names.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The output prefix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def singleEntry(irNode, labelDigit=None, prefix=&#34;&#34;):
    &#34;&#34;&#34;
    Creates a new instance of an IRLine but with only one entry.

    Args:
        irNode: The given &#39;IRNode&#39; entry for this new IRLine.
        labelList: The list of used label names.
        prefix: The output prefix.
    &#34;&#34;&#34;
    entry = IRLine(node=None, tvs=[], labelList=[labelDigit], prefix=prefix)
    entry.treeList.append(irNode)
    return entry</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRLine.boolean_breakdown"><code class="name flex">
<span>def <span class="ident">boolean_breakdown</span></span>(<span>self, root, success, failure)</span>
</code></dt>
<dd>
<section class="desc"><p>Breaks down larger boolean expressions in order to evaluate them</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong></dt>
<dd>The root AST node</dd>
<dt><strong><code>success</code></strong></dt>
<dd>The success label</dd>
<dt><strong><code>failure</code></strong></dt>
<dd>The failure label</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean_breakdown(self, root, success, failure):
    &#34;&#34;&#34;
    Breaks down larger boolean expressions in order to evaluate them

    Args:
        root: The root AST node
        success: The success label
        failure: The failure label
    &#34;&#34;&#34;
    if success not in self.labelList and success != None:
        self.labelList.append(success)
    if failure not in self.labelList and failure != None:
        self.labelList.append(failure)

    index = self.log_ops.index(root.name)
    if index == 0:
        # OR
        tmp_label = max(self.labelList)
        self.labelList.append(tmp_label+1)
        tmpNode = root.children[0]
        if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
            tmpNode = ast.ASTNode(&#34;!=&#34;, None)
            tmpNode.children.append(root.children[0])
            tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

        if tmpNode.name in self.log_ops:
            self.boolean_breakdown(tmpNode, success, tmp_label)
        else:
            self.expression_breakdown(tmpNode, success, tmp_label)

        self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

        tmpNode = root.children[1]
        if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops and (
            tmpNode.children == [] or
            tmpNode.children[0].name not in self.comp_ops and tmpNode.children[0].name not in self.log_ops):

            tmpNode = ast.ASTNode(&#34;!=&#34;, None)
            tmpNode.children.append(root.children[1])
            tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

        if tmpNode.name in self.log_ops:
            self.boolean_breakdown(tmpNode, success, failure)
        else:
            self.expression_breakdown(tmpNode, success, failure)

    elif index == 1:
        # AND
        tmp_label = max(self.labelList)
        self.labelList.append(tmp_label+1)
        tmpNode = root.children[0]
        if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
            tmpNode = ast.ASTNode(&#34;!=&#34;, None)
            tmpNode.children.append(root.children[0])
            tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

        if tmpNode.name in self.log_ops:
            self.boolean_breakdown(tmpNode, tmp_label, failure)
        else:
            self.expression_breakdown(tmpNode, tmp_label, failure)

        self.treeList.append(IRJump(f&#34;&lt;D.{tmp_label}&gt;&#34;))

        tmpNode = root.children[1]
        if tmpNode.name not in self.comp_ops and tmpNode.name not in self.log_ops:
            tmpNode = ast.ASTNode(&#34;!=&#34;, None)
            tmpNode.children.append(root.children[1])
            tmpNode.children.append(ast.ASTNode(&#34;0&#34;, tmpNode))

        if tmpNode.name in self.log_ops:
            self.boolean_breakdown(tmpNode, success, failure)
        else:
            self.expression_breakdown(tmpNode, success, failure)</code></pre>
</details>
</dd>
<dt id="src.optimizer.IRLine.IRLine.expression_breakdown"><code class="name flex">
<span>def <span class="ident">expression_breakdown</span></span>(<span>self, root, success, failure)</span>
</code></dt>
<dd>
<section class="desc"><p>Breaks down smaller expressions in order to evaluate them</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong></dt>
<dd>The root AST node</dd>
<dt><strong><code>success</code></strong></dt>
<dd>The success label</dd>
<dt><strong><code>failure</code></strong></dt>
<dd>The failure label</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expression_breakdown(self, root, success, failure):
    &#34;&#34;&#34;
    Breaks down smaller expressions in order to evaluate them

    Args:
        root: The root AST node
        success: The success label
        failure: The failure label
    &#34;&#34;&#34;
    if success not in self.labelList and success != None:
        self.labelList.append(success)
    if failure not in self.labelList and failure != None:
        self.labelList.append(failure)

    ns = root.list_POT()
    global tmpVarIndex
    ns = [x for x in ns if x.name in self.arth_ops or x.name in self.spec_ops or x.name in self.ass_ops or x.name in self.id_ops or x.name in self.comp_ops]
    for node in ns:
        if node.name in self.comp_ops:

            if node.name in self.comp_ops and node.parent != None and node.parent.name == &#34;!&#34;:
                # logical not means we need to reverse this comparison
                if node.name == &#34;&gt;&#34;: node.name = &#34;&lt;=&#34;
                elif node.name == &#34;&lt;&#34;: node.name = &#34;&gt;=&#34;
                elif node.name == &#34;==&#34;: node.name = &#34;!=&#34;
                elif node.name == &#34;!=&#34;: node.name = &#34;==&#34;
                elif node.name == &#34;&gt;=&#34;: node.name = &#34;&lt;&#34;
                elif node.name == &#34;&lt;=&#34;: node.name = &#34;&gt;&#34;

            self.treeList.append(
                IRIf(
                    node,
                    success,
                    failure,
                    [self.tvs.pop() for x in node.children if len(x.children) != 0]
                )
            )

        elif node.name in self.arth_ops:
            tmpVarIndex += 1
            self.treeList.append(
                IRArth(
                    node,
                    [self.tvs.pop() for x in node.children if len(x.children) != 0],
                    f&#34;tV_{tmpVarIndex}&#34;
                )
            )

            self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

        elif node.name in self.spec_ops:
            var = self.tvs.pop()

            tmpVarIndex += 1

            # Create a temporay AST to deal with storing of the current value of the variable
            # tmpNode = ast.ASTNode(&#34;=&#34;, None)
            # tmpNode.children.append(ast.ASTNode(f&#34;_{tmpVarIndex}&#34;, tmpNode))
            # tmpNode.children.append(ast.ASTNode(var, tmpNode))

            self.treeList.append(
                IRAssignment(
                    f&#34;tV_{tmpVarIndex}&#34;,
                    var
                )
            )
            if [node.children.index(x) for x in node.children if x.name == &#34;NULL&#34;][0] == 1:
                self.treeList.append(
                    IRSpecial(
                        node,
                        var
                    )
                )
            else:
                self.treeList.insert(len(self.treeList) - 2,
                    IRSpecial(
                        node,
                        var
                    )
                )

            self.tvs.append(f&#34;tV_{tmpVarIndex}&#34;)

        elif node.name in self.ass_ops:
            if self.ass_ops.index(node.name) == 0:
                lhs = None
                rhs = None
                # Case 1: Assignment is constant. ie. int i = 0
                if len(node.children[1].children) == 0:
                    lhs = self.tvs.pop()
                    rhs = f&#34;{node.children[1].name}&#34;
                # Case 2: Assignment is complex
                else:
                    lhs = f&#34;rV_{node.children[0].children[len(node.children[0].children)-1].name}&#34;
                    rhs = self.tvs.pop()

                self.treeList.append(
                        IRAssignment(
                            lhs,
                            rhs
                        )
                    )
            else:
                # create a temporary parent node
                p = ast.ASTNode(&#34;=&#34;, None)

                # append the variable who is assigned a value as its first child
                p.children.append(node.children[0])

                # create a right subtree with the correct operation
                r = ast.ASTNode(node.name[:-1], p)
                p.children.append(r)

                rc = None
                lc = None

                # assign the variable as the left operand of the new expression
                if len(node.children[1].children) &gt; 0:
                    rc = ast.ASTNode(self.tvs.pop(), r)
                else:
                    rc = node.children[1]

                # assign the variable as the left operand of the new expression
                if len(node.children[0].children) &gt; 0:
                    lc = ast.ASTNode(self.tvs.pop(), r)
                else:
                    lc = node.children[0]

                # assign the remaining operations as the right operand of the new expression

                r.children.append(lc)
                r.children.append(rc)

                self.expression_breakdown(p, success, failure)

        elif node.name in self.id_ops:
            if node.name == &#34;var&#34;:
                self.tvs.append(f&#34;rV_{node.children[len(node.children)-1].name}&#34;)
            elif node.name == &#34;call&#34;:
                # list of indices that correspond to the complex parameters of the function call
                complexP = [node.children[0].children.index(x) for x in node.children[0].children if len(x.children) &gt; 0]
                simpleP = [x for x in range(len(node.children[0].children)) if x not in complexP]

                params = [self.tvs.pop() for x in range(len(node.children[0].children)) if x in complexP]

                tmpVarIndex += 1
                self.treeList.append(
                    IRFunctionAssign(
                        node,
                        [params.pop() if x in complexP else node.children[0].children[x].name for x in range(len(node.children[0].children))],
                        f&#34;tV_{tmpVarIndex}&#34;
                    )
                )

                self.tvs.append(self.treeList[-1].lhs)</code></pre>
</details>
</dd>
<dt id="src.optimizer.IRLine.IRLine.retrieve"><code class="name flex">
<span>def <span class="ident">retrieve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the updated tempoary variable storage and list of unavailable label names for the future.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tvs</code></strong></dt>
<dd>The current tempoary variable storage</dd>
<dt><strong><code>labelList</code></strong></dt>
<dd>The list of used label names</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve(self):
    &#34;&#34;&#34;
    Retrieves the updated tempoary variable storage and list of unavailable label names for the future.

    Returns:
        tvs: The current tempoary variable storage
        labelList: The list of used label names
    &#34;&#34;&#34;
    return self.tvs, self.labelList</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRNode"><code class="flex name class">
<span>class <span class="ident">IRNode</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract intermediate representation node. Base class for all other IR representations other than IRLines.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRNode():
    &#34;&#34;&#34;
    Abstract intermediate representation node. Base class for all other IR representations other than IRLines.
    &#34;&#34;&#34;
    def __init__(self):
        pass

    def __str__(self):
        pass

    def asm(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRArth" href="#src.optimizer.IRLine.IRArth">IRArth</a></li>
<li><a title="src.optimizer.IRLine.IRAssignment" href="#src.optimizer.IRLine.IRAssignment">IRAssignment</a></li>
<li><a title="src.optimizer.IRLine.IRBracket" href="#src.optimizer.IRLine.IRBracket">IRBracket</a></li>
<li><a title="src.optimizer.IRLine.IRFunctionAssign" href="#src.optimizer.IRLine.IRFunctionAssign">IRFunctionAssign</a></li>
<li><a title="src.optimizer.IRLine.IRFunctionDecl" href="#src.optimizer.IRLine.IRFunctionDecl">IRFunctionDecl</a></li>
<li><a title="src.optimizer.IRLine.IRGoTo" href="#src.optimizer.IRLine.IRGoTo">IRGoTo</a></li>
<li><a title="src.optimizer.IRLine.IRIf" href="#src.optimizer.IRLine.IRIf">IRIf</a></li>
<li><a title="src.optimizer.IRLine.IRJump" href="#src.optimizer.IRLine.IRJump">IRJump</a></li>
<li><a title="src.optimizer.IRLine.IRReturn" href="#src.optimizer.IRLine.IRReturn">IRReturn</a></li>
<li><a title="src.optimizer.IRLine.IRSpecial" href="#src.optimizer.IRLine.IRSpecial">IRSpecial</a></li>
<li><a title="src.optimizer.IRLine.IRVariableInit" href="#src.optimizer.IRLine.IRVariableInit">IRVariableInit</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRNode.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRReturn"><code class="flex name class">
<span>class <span class="ident">IRReturn</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a return.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>The return value. Can be 'None' for void functions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRReturn(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a return.
    &#34;&#34;&#34;
    def __init__(self, value):
        &#34;&#34;&#34;
        Args:
            value: The return value. Can be &#39;None&#39; for void functions.
        &#34;&#34;&#34;
        self.value = value

    def __str__(self):
        if self.value:
            return f&#34;return {self.value};&#34;
        else:
            return f&#34;return;&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRReturn
        &#34;&#34;&#34;

        asml = []
        if self.value:
            asml.append(asmn.ASMNode(&#34;mov&#34;, self.value, &#34;rax&#34;))
        asml.extend([
            asmn.ASMNode(&#34;ret&#34;, None, None, dontTouch=True)
        ])

        return asml</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRReturn.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRReturn" href="#src.optimizer.IRLine.IRReturn"><code>IRReturn</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRReturn
    &#34;&#34;&#34;

    asml = []
    if self.value:
        asml.append(asmn.ASMNode(&#34;mov&#34;, self.value, &#34;rax&#34;))
    asml.extend([
        asmn.ASMNode(&#34;ret&#34;, None, None, dontTouch=True)
    ])

    return asml</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRSpecial"><code class="flex name class">
<span>class <span class="ident">IRSpecial</span></span>
<span>(</span><span>node, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a special operation assignment. Special operations consist of pre/post increment and decrement operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node for the operation</dd>
<dt><strong><code>var</code></strong></dt>
<dd>The variable which the operation is applied to</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRSpecial(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a special operation assignment. Special operations consist of pre/post increment and decrement operations.
    &#34;&#34;&#34;
    def __init__(self, node, var):
        &#34;&#34;&#34;
        Args:
            node: The AST node for the operation
            var: The variable which the operation is applied to
        &#34;&#34;&#34;
        self.node = node
        self.var = var
        self.operation = self.node.name[0]


    def __str__(self):
        return f&#34;{self.var} = {self.var} {self.operation} 1;&#34;

    def asm(self):
        &#34;&#34;&#34;
        Constructs assembly string of a special (i.e. inc/dec) instruction
        Returns:
            List of necessary ASMNodes representing assembly code.
        &#34;&#34;&#34;

        if self.operation == &#34;+&#34;:
            return [asmn.ASMNode(&#34;inc&#34;, self.var, None)]
        elif self.operation == &#39;-&#39;:
            return [asmn.ASMNode(&#34;dec&#34;, self.var, None)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRSpecial.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs assembly string of a special (i.e. inc/dec) instruction</p>
<h2 id="returns">Returns</h2>
<p>List of necessary ASMNodes representing assembly code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Constructs assembly string of a special (i.e. inc/dec) instruction
    Returns:
        List of necessary ASMNodes representing assembly code.
    &#34;&#34;&#34;

    if self.operation == &#34;+&#34;:
        return [asmn.ASMNode(&#34;inc&#34;, self.var, None)]
    elif self.operation == &#39;-&#39;:
        return [asmn.ASMNode(&#34;dec&#34;, self.var, None)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.optimizer.IRLine.IRVariableInit"><code class="flex name class">
<span>class <span class="ident">IRVariableInit</span></span>
<span>(</span><span>modifiers, typ, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Intermediate representation node for a variable initialization.</p>
<h2 id="args">Args</h2>
<p>modifiers:
type:
var:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRVariableInit(IRNode):
    &#34;&#34;&#34;
    Intermediate representation node for a variable initialization.
    &#34;&#34;&#34;
    def __init__(self, modifiers, typ, var):
        &#34;&#34;&#34;
        Args:
            modifiers:
            type:
            var:
        &#34;&#34;&#34;
        self.modifiers = modifiers

        self.typ = typ

        self.var = var

    def __str__(self):
        return f&#34;{self.modifiers}{self.typ} {self.var};&#34;

    def asm(self):
        &#34;&#34;&#34;
        Generates assembly representation of this node, using the variable names instead of registers

        Returns:
            The assembly representation of an IRVariableInit
        &#34;&#34;&#34;

        return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.optimizer.IRLine.IRVariableInit.asm"><code class="name flex">
<span>def <span class="ident">asm</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates assembly representation of this node, using the variable names instead of registers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>assembly</code> <code>representation</code> of <code>an</code> <a title="src.optimizer.IRLine.IRVariableInit" href="#src.optimizer.IRLine.IRVariableInit"><code>IRVariableInit</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asm(self):
    &#34;&#34;&#34;
    Generates assembly representation of this node, using the variable names instead of registers

    Returns:
        The assembly representation of an IRVariableInit
    &#34;&#34;&#34;

    return []</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.optimizer" href="index.html">src.optimizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.optimizer.IRLine.IRArth" href="#src.optimizer.IRLine.IRArth">IRArth</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRArth.asm" href="#src.optimizer.IRLine.IRArth.asm">asm</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRArth.fileInit" href="#src.optimizer.IRLine.IRArth.fileInit">fileInit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRAssignment" href="#src.optimizer.IRLine.IRAssignment">IRAssignment</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRAssignment.asm" href="#src.optimizer.IRLine.IRAssignment.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRBracket" href="#src.optimizer.IRLine.IRBracket">IRBracket</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRBracket.asm" href="#src.optimizer.IRLine.IRBracket.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRFunctionAssign" href="#src.optimizer.IRLine.IRFunctionAssign">IRFunctionAssign</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRFunctionAssign.LineFromFile" href="#src.optimizer.IRLine.IRFunctionAssign.LineFromFile">LineFromFile</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRFunctionAssign.asm" href="#src.optimizer.IRLine.IRFunctionAssign.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRFunctionDecl" href="#src.optimizer.IRLine.IRFunctionDecl">IRFunctionDecl</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRFunctionDecl.asm" href="#src.optimizer.IRLine.IRFunctionDecl.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRGoTo" href="#src.optimizer.IRLine.IRGoTo">IRGoTo</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRGoTo.asm" href="#src.optimizer.IRLine.IRGoTo.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRIf" href="#src.optimizer.IRLine.IRIf">IRIf</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRIf.asm" href="#src.optimizer.IRLine.IRIf.asm">asm</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRIf.fileInit" href="#src.optimizer.IRLine.IRIf.fileInit">fileInit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRJump" href="#src.optimizer.IRLine.IRJump">IRJump</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRJump.asm" href="#src.optimizer.IRLine.IRJump.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRLine" href="#src.optimizer.IRLine.IRLine">IRLine</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRLine.boolean_breakdown" href="#src.optimizer.IRLine.IRLine.boolean_breakdown">boolean_breakdown</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRLine.expression_breakdown" href="#src.optimizer.IRLine.IRLine.expression_breakdown">expression_breakdown</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRLine.retrieve" href="#src.optimizer.IRLine.IRLine.retrieve">retrieve</a></code></li>
<li><code><a title="src.optimizer.IRLine.IRLine.singleEntry" href="#src.optimizer.IRLine.IRLine.singleEntry">singleEntry</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRNode" href="#src.optimizer.IRLine.IRNode">IRNode</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRNode.asm" href="#src.optimizer.IRLine.IRNode.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRReturn" href="#src.optimizer.IRLine.IRReturn">IRReturn</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRReturn.asm" href="#src.optimizer.IRLine.IRReturn.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRSpecial" href="#src.optimizer.IRLine.IRSpecial">IRSpecial</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRSpecial.asm" href="#src.optimizer.IRLine.IRSpecial.asm">asm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.optimizer.IRLine.IRVariableInit" href="#src.optimizer.IRLine.IRVariableInit">IRVariableInit</a></code></h4>
<ul class="">
<li><code><a title="src.optimizer.IRLine.IRVariableInit.asm" href="#src.optimizer.IRLine.IRVariableInit.asm">asm</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>