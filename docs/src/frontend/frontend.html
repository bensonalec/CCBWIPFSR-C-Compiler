<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.frontend.frontend API documentation</title>
<meta name="description" content="This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.frontend.frontend</code></h1>
</header>
<section id="section-intro">
<p>This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to determine which portion is run.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to determine which portion is run.
&#34;&#34;&#34;
import argparse
import importlib

from rply.errors import LexingError
from pptree import *

lex = importlib.import_module(&#34;lexer&#34;, &#34;.&#34;)
par = importlib.import_module(&#34;parser&#34;, &#34;.&#34;)
btp = importlib.import_module(&#34;bnfToParser&#34;, &#34;.&#34;)


def getTree(head,level):
    &#34;&#34;&#34;
    Outputs a string version of the Abstract Syntax Tree that can be used in unit testing. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    
    Returns:
        A string of the nodes in the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    out = (level,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            out += getTree(node,level)
    return out

def printTree(head,level):
    &#34;&#34;&#34;
    Prints a simple version of the tree for output. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    print(level,&#34;:&#34;,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            printTree(node,level)

def prettyPrint(head,level,parentNode):
    &#34;&#34;&#34;
    Prints the Abstract Syntax Tree using a tree library (pptree)

    Args:
        head: The head node of the tree
        level: The level the tree is on.
        parentNode: The parent node of the tree.
    &#34;&#34;&#34;
    if(level == 0):
        headNode = Node(head.token)
        parentNode = headNode
    
    token = head.token
    content = head.content
    for ne in content:
        if(type(ne) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            nodeName = Node(ne.token,parentNode)
        else:
            
            nodeName = Node(ne,parentNode)
        if(type(ne) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            prettyPrint(ne,level+1,nodeName)
    if(level == 0):
        #this is a function from the pptree
        print_tree(headNode)
    

#main function to control the frontend with different command line options.
def main(args, fi):
    &#34;&#34;&#34;
    The main function of this, takes in command line input via an object from argparse, and the name of the file.
    
    Args:
        args: The object that contains the command line arguements.
        fi: The file object that is open.
    &#34;&#34;&#34;

    if args.bnf:
        btp.main(args.bnf)
        importlib.reload(par)
    

    try:

        #Read in file
        text_input = fi.read()
        fi.close()

        #setup lexer, produce tokens, check for invalid tokens
        lexer = lex.Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        lex.validateTokens(tokens)
        
        #set up parser and parse the given tokens
        pg = par.Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(tokens)

    except LexingError as err:
        print(&#34;Received error(s) from token validation. Exiting...&#34;)
        exit()

    except AssertionError as err:
        # parser has it&#39;s own detailed error printing
        pg.print_error()
        print(&#34;Received AssertionError(s) from parser, continuing with what was parsed...\n&#34;)

    except BaseException as err:
        print(f&#34;BaseException: {err}. Exiting...&#34;)
        exit()
    
    # Retrieve the head of the AST
    head = pg.getTree()


    #if -l or --lex is true print the tokens from the lexer 
    if args.lex or args.all:
        temp_print = lexer.lex(text_input) #need to run lexer so that tokens are deleted for parser
        for i in temp_print:
            print(i)
        #print(tokensToString(tokens))

    if(args.tree):
        print(getTree(head,0))
    #print the tree starting at the head
    else:
        if(args.pretty):
            prettyPrint(head,0,None)
        else:
            printTree(head,0)

if __name__ == &#34;__main__&#34;:
    #command line arguements

    #decription of the comiler
    cmd_options = argparse.ArgumentParser(description=&#39;Frontend of the compiler. Can produce tokens and syntax tree&#39;)
    
    #input file option
    cmd_options.add_argument(&#39;input_file&#39;, metavar=&#39;&lt;filename.c&gt;&#39;, type=str, help=&#39;Input c file.&#39;)
    
    #Arguement to print tokens from lexer
    cmd_options.add_argument(&#39;-l&#39;,&#39;--lex&#39;, help=&#39;Prints out tokens from lexer&#39;, action=&#39;store_true&#39;)
    
    #Print all output from lexer, parser, etc....
    cmd_options.add_argument(&#39;-a&#39;,&#39;--all&#39;, help=&#39;Prints out all intermediate ouputs.&#39;, action=&#34;store_true&#34;)

    #Prints string representation of parse tree....
    cmd_options.add_argument(&#39;-t&#39;,&#39;--tree&#39;, help=&#39;Prints string representation of parse tree.&#39;, action=&#34;store_true&#34;)

    cmd_options.add_argument(&#39;-p&#39;,&#39;--pretty&#39;,help=&#39;Prints a pretty verision of the tree, and does not print the tokens&#39;, action=&#34;store_true&#34;)

    cmd_options.add_argument(&#39;-b&#39;, &#39;--bnf&#39;, nargs=&#39;?&#39;, const=&#39;./BNF_definition&#39;, type=str, help=&#39;Rebuilds the parser using the current BNF grammar&#39;)

    #generate arguements
    args = cmd_options.parse_args()


    #open file and pass into main.
    if args.input_file and args.input_file.endswith(&#34;.c&#34;):
        fi = open(args.input_file, &#34;r&#34;)
    else:
        #if not c file.
        if not args.input_file.endswith(&#34;.c&#34;):
            print(&#34;Error file must end with .c&#34;)
        cmd_options.print_help()
        exit()
    main(args, fi)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.frontend.frontend.getTree"><code class="name flex">
<span>def <span class="ident">getTree</span></span>(<span>head, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Outputs a string version of the Abstract Syntax Tree that can be used in unit testing. Calls itself recursively</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong></dt>
<dd>The head node of the tree.</dd>
<dt><strong><code>level</code></strong></dt>
<dd>The current level of the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string of the nodes in the tree.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTree(head,level):
    &#34;&#34;&#34;
    Outputs a string version of the Abstract Syntax Tree that can be used in unit testing. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    
    Returns:
        A string of the nodes in the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    out = (level,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            out += getTree(node,level)
    return out</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args, fi)</span>
</code></dt>
<dd>
<section class="desc"><p>The main function of this, takes in command line input via an object from argparse, and the name of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>The object that contains the command line arguements.</dd>
<dt><strong><code>fi</code></strong></dt>
<dd>The file object that is open.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args, fi):
    &#34;&#34;&#34;
    The main function of this, takes in command line input via an object from argparse, and the name of the file.
    
    Args:
        args: The object that contains the command line arguements.
        fi: The file object that is open.
    &#34;&#34;&#34;

    if args.bnf:
        btp.main(args.bnf)
        importlib.reload(par)
    

    try:

        #Read in file
        text_input = fi.read()
        fi.close()

        #setup lexer, produce tokens, check for invalid tokens
        lexer = lex.Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        lex.validateTokens(tokens)
        
        #set up parser and parse the given tokens
        pg = par.Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(tokens)

    except LexingError as err:
        print(&#34;Received error(s) from token validation. Exiting...&#34;)
        exit()

    except AssertionError as err:
        # parser has it&#39;s own detailed error printing
        pg.print_error()
        print(&#34;Received AssertionError(s) from parser, continuing with what was parsed...\n&#34;)

    except BaseException as err:
        print(f&#34;BaseException: {err}. Exiting...&#34;)
        exit()
    
    # Retrieve the head of the AST
    head = pg.getTree()


    #if -l or --lex is true print the tokens from the lexer 
    if args.lex or args.all:
        temp_print = lexer.lex(text_input) #need to run lexer so that tokens are deleted for parser
        for i in temp_print:
            print(i)
        #print(tokensToString(tokens))

    if(args.tree):
        print(getTree(head,0))
    #print the tree starting at the head
    else:
        if(args.pretty):
            prettyPrint(head,0,None)
        else:
            printTree(head,0)</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.prettyPrint"><code class="name flex">
<span>def <span class="ident">prettyPrint</span></span>(<span>head, level, parentNode)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints the Abstract Syntax Tree using a tree library (pptree)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong></dt>
<dd>The head node of the tree</dd>
<dt><strong><code>level</code></strong></dt>
<dd>The level the tree is on.</dd>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the tree.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prettyPrint(head,level,parentNode):
    &#34;&#34;&#34;
    Prints the Abstract Syntax Tree using a tree library (pptree)

    Args:
        head: The head node of the tree
        level: The level the tree is on.
        parentNode: The parent node of the tree.
    &#34;&#34;&#34;
    if(level == 0):
        headNode = Node(head.token)
        parentNode = headNode
    
    token = head.token
    content = head.content
    for ne in content:
        if(type(ne) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            nodeName = Node(ne.token,parentNode)
        else:
            
            nodeName = Node(ne,parentNode)
        if(type(ne) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            prettyPrint(ne,level+1,nodeName)
    if(level == 0):
        #this is a function from the pptree
        print_tree(headNode)</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.printTree"><code class="name flex">
<span>def <span class="ident">printTree</span></span>(<span>head, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints a simple version of the tree for output. Calls itself recursively</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong></dt>
<dd>The head node of the tree.</dd>
<dt><strong><code>level</code></strong></dt>
<dd>The current level of the tree.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printTree(head,level):
    &#34;&#34;&#34;
    Prints a simple version of the tree for output. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    print(level,&#34;:&#34;,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.AbstractSyntaxTree(&#34;sample&#34;,&#34;sample&#34;))):
            printTree(node,level)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.frontend" href="index.html">src.frontend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.frontend.frontend.getTree" href="#src.frontend.frontend.getTree">getTree</a></code></li>
<li><code><a title="src.frontend.frontend.main" href="#src.frontend.frontend.main">main</a></code></li>
<li><code><a title="src.frontend.frontend.prettyPrint" href="#src.frontend.frontend.prettyPrint">prettyPrint</a></code></li>
<li><code><a title="src.frontend.frontend.printTree" href="#src.frontend.frontend.printTree">printTree</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>