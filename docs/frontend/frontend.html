<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>src.frontend.frontend API documentation</title>
<meta name="description" content="This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.frontend.frontend</code></h1>
</header>
<section id="section-intro">
<p>This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to determine which portion is run.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module acts as the interface for running all the seperate portions of the front end. It allows
for command line arguments that can be used to determine which portion is run.
&#34;&#34;&#34;
import os
import argparse
import importlib
import traceback
import sys

from rply.errors import LexingError
from copy import deepcopy

lex = importlib.import_module(&#34;lexer&#34;, __name__)
par = importlib.import_module(&#34;parser&#34;, __name__)
btp = importlib.import_module(&#34;bnfToParser&#34;, __name__)
ast = importlib.import_module(&#34;AST_builder&#34;, __name__)
sem = importlib.import_module(&#34;semantics&#34;, __name__)
pre = importlib.import_module(&#34;preprocessor&#34;, __name__)


def getTree(head,level):
    &#34;&#34;&#34;
    Outputs a string version of the ParseTree that can be used in unit testing. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    
    Returns:
        A string of the nodes in the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    out = (level,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            out += getTree(node,level)
    return out


def print_tokens(tokens):
    &#34;&#34;&#34;
    Prints tokens returned from Lexer

    Args:
        tokens: Tokens generated from the Lexer
    &#34;&#34;&#34;
    print(lex.tokensToString(deepcopy(tokens)))


def getListView(head,level):
    &#34;&#34;&#34;
    Prints a simple list version of the tree for output. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    &#34;&#34;&#34;
    string = &#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    string += f&#34;{level} : {li}\n&#34;

    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            string += getListView(node,level)

    return string


def pprint_tree(node, file=None, _prefix=&#34;&#34;, _last=True):
    &#34;&#34;&#34;
    Prints the ParseTree in depth first order

    Args: 
        node: The head node of the tree.
        file: The file to be written to (Defaults to Stdout).
        _prefix: A string indicating the spacing from the left side of the screen.
        _last: A boolean that indicates if a node is the last in it&#39;s immediate surroundings.
    &#34;&#34;&#34;
    if type(node) == type(par.ParseTree(&#34;test&#34;, &#34;test&#34;)):
        print(_prefix, &#34;`-- &#34; if _last else &#34;|-- &#34;, node.token, sep=&#34;&#34;, file=file)
        _prefix += &#34;    &#34; if _last else &#34;|   &#34;
        child_count = len(node.content)
        for i, child in enumerate(node.content):
            _last = i == (child_count - 1)
            pprint_tree(child, file, _prefix, _last)
    else:
        print(_prefix, &#34;`-- &#34; if _last else &#34;|-- &#34;, node, sep=&#34;&#34;, file=file)

def main(args, fi):
    &#34;&#34;&#34;
    The main function of the frontend, takes in command line input via an object from argparse, and the name of the file.
    
    Args:
        args: The object that contains the command line arguements.
        fi: The file object that is open.
    &#34;&#34;&#34;

    if args.bnf:
        btp.main(args.bnf)
        importlib.reload(par)
    

    try:

        #print(sys.modules)

        #Read in file
        text_input = fi.read()
        fi.close()

        #Pre-process the text
        text_input = pre.run(text_input)

        #setup lexer, produce tokens, check for invalid tokens
        lexer = lex.Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        lex.validateTokens(tokens)
        
        if args.lex or args.all:
            # Print the tokens from the lexer 
            print_tokens(tokens)

        #set up parser and parse the given tokens
        pg = par.Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(tokens)

        # Retrieve the head of the parse tree
        head = pg.getTree()

        if args.tree or args.all:
            # Represent parse tree as a list with levels
            print(getListView(head, 0))

        if args.all:
            # Represent parse tree as single line (mainly for unit testing)
            print(getTree(head, 0)) 

        if args.pretty or args.all:
            # Pretty print parse tree
            pprint_tree(head)

        # Build Abstract Syntax Tree
        astree = ast.buildAST(head)

        if args.ast or args.all:
            # Pretty print AST
            ast.print_AST(astree)

        # Initialize symbol table and begin semantic analysis
        sym = sem.symbol_table(astree)
        sym.analyze()

        if args.symbol_table or args.all:
            sym.print_symbol_table()
            print (&#34;&#34;)
            sym.print_unknown_symbols()

    except LexingError as err:
        print(&#34;Received error(s) from token validation. Exiting...&#34;)
        exit()

    except AssertionError as err:
        # parser has it&#39;s own detailed error printing
        pg.print_error()
        print(&#34;Received AssertionError(s) from parser, continuing with what was parsed...\n&#34;)

    except BaseException as err:
        traceback.print_exc()
        print(f&#34;Unrecoverable exception occured. Exiting...&#34;)
        exit()

    return astree, sym

if __name__ == &#34;__main__&#34;:
    #command line arguements

    #decription of the comiler
    cmd_options = argparse.ArgumentParser(description=&#39;Frontend of the compiler. Can produce tokens and syntax tree&#39;)
    
    cmd_options.add_argument(&#39;--all&#39;,help=&#39;Prints out all intermediate representations as they are encountered in the compilation process&#39;, action=&#34;store_true&#34;)

    #input file option
    cmd_options.add_argument(&#39;input_file&#39;, metavar=&#39;&lt;filename.c&gt;&#39;, type=str, help=&#39;Input c file.&#39;)
    
    #Arguement to print tokens from lexer
    cmd_options.add_argument(&#39;-l&#39;,&#39;--lex&#39;, help=&#39;Prints out tokens from lexer&#39;, action=&#39;store_true&#39;)

    #Prints string representation of parse tree....
    cmd_options.add_argument(&#39;-t&#39;,&#39;--tree&#39;, help=&#39;Prints string representation of parse tree.&#39;, action=&#34;store_true&#34;)

    cmd_options.add_argument(&#39;-p&#39;,&#39;--pretty&#39;,help=&#39;Prints a pretty verision of the tree, and does not print the tokens&#39;, action=&#34;store_true&#34;)

    #Print all output from lexer, parser, etc....
    cmd_options.add_argument(&#39;-a&#39;,&#39;--ast&#39;, help=&#39;Prints out the abstract syntax tree.&#39;, action=&#34;store_true&#34;)

    cmd_options.add_argument(&#39;-s&#39;,&#39;--symbol_table&#39;, help=&#39;Prints out the known and unknown symbols encountered during semantic analysis.&#39;, action=&#34;store_true&#34;)

    cmd_options.add_argument(&#39;-b&#39;, &#39;--bnf&#39;, nargs=&#39;?&#39;, const=os.path.realpath(&#34;./BNF_definition&#34;), type=str, help=&#39;Rebuilds the parser using the current BNF grammar&#39;)


    #generate arguements
    args = cmd_options.parse_args()


    #open file and pass into main.
    if args.input_file and args.input_file.endswith(&#34;.c&#34;):
        fi = open(args.input_file, &#34;r&#34;)
    else:
        #if not c file.
        if not args.input_file.endswith(&#34;.c&#34;):
            print(&#34;Error file must end with .c&#34;)
        cmd_options.print_help()
        exit()
    main(args, fi)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.frontend.frontend.getListView"><code class="name flex">
<span>def <span class="ident">getListView</span></span>(<span>head, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints a simple list version of the tree for output. Calls itself recursively</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong></dt>
<dd>The head node of the tree.</dd>
<dt><strong><code>level</code></strong></dt>
<dd>The current level of the tree.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getListView(head,level):
    &#34;&#34;&#34;
    Prints a simple list version of the tree for output. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    &#34;&#34;&#34;
    string = &#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    string += f&#34;{level} : {li}\n&#34;

    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            string += getListView(node,level)

    return string</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.getTree"><code class="name flex">
<span>def <span class="ident">getTree</span></span>(<span>head, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Outputs a string version of the ParseTree that can be used in unit testing. Calls itself recursively</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong></dt>
<dd>The head node of the tree.</dd>
<dt><strong><code>level</code></strong></dt>
<dd>The current level of the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string of the nodes in the tree.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTree(head,level):
    &#34;&#34;&#34;
    Outputs a string version of the ParseTree that can be used in unit testing. Calls itself recursively

    Args:
        head: The head node of the tree.
        level: The current level of the tree.
    
    Returns:
        A string of the nodes in the tree.
    &#34;&#34;&#34;
    level += 1
    token = head.token
    content = head.content
    li = []
    out = &#34;&#34;
    for node in content:
        if(type(node) != type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            li.append(node)
        else:
            li.append(node.token)
    
    out = (level,li)


    #iterate through the components of the BNF
    for node in content:
        if(type(node) == type(par.ParseTree(&#34;sample&#34;,&#34;sample&#34;))):
            out += getTree(node,level)
    return out</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args, fi)</span>
</code></dt>
<dd>
<section class="desc"><p>The main function of the frontend, takes in command line input via an object from argparse, and the name of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>The object that contains the command line arguements.</dd>
<dt><strong><code>fi</code></strong></dt>
<dd>The file object that is open.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args, fi):
    &#34;&#34;&#34;
    The main function of the frontend, takes in command line input via an object from argparse, and the name of the file.
    
    Args:
        args: The object that contains the command line arguements.
        fi: The file object that is open.
    &#34;&#34;&#34;

    if args.bnf:
        btp.main(args.bnf)
        importlib.reload(par)
    

    try:

        #print(sys.modules)

        #Read in file
        text_input = fi.read()
        fi.close()

        #Pre-process the text
        text_input = pre.run(text_input)

        #setup lexer, produce tokens, check for invalid tokens
        lexer = lex.Lexer().get_lexer()
        tokens = lexer.lex(text_input)
        lex.validateTokens(tokens)
        
        if args.lex or args.all:
            # Print the tokens from the lexer 
            print_tokens(tokens)

        #set up parser and parse the given tokens
        pg = par.Parser()
        pg.parse()
        parser = pg.get_parser()
        parser.parse(tokens)

        # Retrieve the head of the parse tree
        head = pg.getTree()

        if args.tree or args.all:
            # Represent parse tree as a list with levels
            print(getListView(head, 0))

        if args.all:
            # Represent parse tree as single line (mainly for unit testing)
            print(getTree(head, 0)) 

        if args.pretty or args.all:
            # Pretty print parse tree
            pprint_tree(head)

        # Build Abstract Syntax Tree
        astree = ast.buildAST(head)

        if args.ast or args.all:
            # Pretty print AST
            ast.print_AST(astree)

        # Initialize symbol table and begin semantic analysis
        sym = sem.symbol_table(astree)
        sym.analyze()

        if args.symbol_table or args.all:
            sym.print_symbol_table()
            print (&#34;&#34;)
            sym.print_unknown_symbols()

    except LexingError as err:
        print(&#34;Received error(s) from token validation. Exiting...&#34;)
        exit()

    except AssertionError as err:
        # parser has it&#39;s own detailed error printing
        pg.print_error()
        print(&#34;Received AssertionError(s) from parser, continuing with what was parsed...\n&#34;)

    except BaseException as err:
        traceback.print_exc()
        print(f&#34;Unrecoverable exception occured. Exiting...&#34;)
        exit()

    return astree, sym</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.pprint_tree"><code class="name flex">
<span>def <span class="ident">pprint_tree</span></span>(<span>node, file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints the ParseTree in depth first order</p>
<p>Args:
node: The head node of the tree.
file: The file to be written to (Defaults to Stdout).
_prefix: A string indicating the spacing from the left side of the screen.
_last: A boolean that indicates if a node is the last in it's immediate surroundings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint_tree(node, file=None, _prefix=&#34;&#34;, _last=True):
    &#34;&#34;&#34;
    Prints the ParseTree in depth first order

    Args: 
        node: The head node of the tree.
        file: The file to be written to (Defaults to Stdout).
        _prefix: A string indicating the spacing from the left side of the screen.
        _last: A boolean that indicates if a node is the last in it&#39;s immediate surroundings.
    &#34;&#34;&#34;
    if type(node) == type(par.ParseTree(&#34;test&#34;, &#34;test&#34;)):
        print(_prefix, &#34;`-- &#34; if _last else &#34;|-- &#34;, node.token, sep=&#34;&#34;, file=file)
        _prefix += &#34;    &#34; if _last else &#34;|   &#34;
        child_count = len(node.content)
        for i, child in enumerate(node.content):
            _last = i == (child_count - 1)
            pprint_tree(child, file, _prefix, _last)
    else:
        print(_prefix, &#34;`-- &#34; if _last else &#34;|-- &#34;, node, sep=&#34;&#34;, file=file)</code></pre>
</details>
</dd>
<dt id="src.frontend.frontend.print_tokens"><code class="name flex">
<span>def <span class="ident">print_tokens</span></span>(<span>tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints tokens returned from Lexer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tokens</code></strong></dt>
<dd>Tokens generated from the Lexer</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_tokens(tokens):
    &#34;&#34;&#34;
    Prints tokens returned from Lexer

    Args:
        tokens: Tokens generated from the Lexer
    &#34;&#34;&#34;
    print(lex.tokensToString(deepcopy(tokens)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.frontend" href="index.html">src.frontend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.frontend.frontend.getListView" href="#src.frontend.frontend.getListView">getListView</a></code></li>
<li><code><a title="src.frontend.frontend.getTree" href="#src.frontend.frontend.getTree">getTree</a></code></li>
<li><code><a title="src.frontend.frontend.main" href="#src.frontend.frontend.main">main</a></code></li>
<li><code><a title="src.frontend.frontend.pprint_tree" href="#src.frontend.frontend.pprint_tree">pprint_tree</a></code></li>
<li><code><a title="src.frontend.frontend.print_tokens" href="#src.frontend.frontend.print_tokens">print_tokens</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>